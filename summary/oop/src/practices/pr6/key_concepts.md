# Ключевые понятия

 - [Delegate(Делегаты)](#Делегаты)
 - [MulticastDelegate](#Мультикаст-делегаты)
 - [Цепочки делегатов “+=”;  “-=”](#Цепочки-делегатов)
 - [Лямбда-выражения “=>”](#Лямбда-выражения)
 - [Функции обратного вызова (callback)](#Функции-обратного-вызова-callback)
 - [Event (Событие)](#event-Событие)
 - [EventHandler (Обработчик события)](#eventhandler-Обработчик-события)
 - [класс Sender и классы Receivers](#Класс-sender-и-классы-receivers)
 - [класс EventArgs и его потомки](#Класс-eventargs-и-его-потомки)
 - [Класс Receiver](#Класс-receiver)
 - [Связывание обработчика с событием](#Связывание-обработчика-с-событием)
 - [Отключение обработчика](#Отключение-обработчика)
 - [Динамическое связывание событий с их обработчиками](#Динамическое-связывание-событий-с-их-обработчиками)

Хотя ключевых понятий указано много, по сути всё, что нужно изучить, это делегаты, события и лямбда выражения.
По сути всё что тут есть относится к делегатам или является ими.

Многие ключевые понятия по сути дублируются, однако, оставляем как в оригинальной методичке.

## Делегаты

Делегаты - это указатели на методы и с помощью делегатов мы можем вызвать методы по указателю.

### Определение делегатов

Для объявления делегата используется ключевое слово `delegate`, после которого идет возвращаемый тип, название и параметры. Например:

```C#
delegate void Message();
```

Делегат `Message` в качестве возвращаемого типа имеет тип `void` (то есть ничего не возвращает) и не принимает никаких параметров. Это значит, что этот делегат может указывать на любой метод, который не принимает никаких параметров и ничего не возвращает.

Рассмотрим примение этого делегата:

```C#
using System;

public class Program
{
    void Hello() => Console.WriteLine("Amogus ඞ");  // Объявляем метод
    delegate void Message();  // Объявляем делегат

    public static void Main()
    {
        Program p = new Program();  // Создаем экземпляр класса Program
        Message mes = p.Hello;      // Присваиваем переменной mes адрес метода Hello
        mes();                      // Вызываем метод Hello, выведет: Amogus ඞ
    }
}
```

Делегаты могут быть переданы как параметры метода, методы могут возвращать делегаты, делегаты
могут запускать несколько методов сразу.

> Более подробно о [делегатах](../../appendix/delegate.md)

## Мультикаст-делегаты

Делегаты, которые включают в себя больше одного метода, называют **мультикаст-делегатами**, [подробнее](../../appendix/delegate.md#Добавление-методов-в-делегат).

## Цепочки делегатов

Так как делегаты могут содержать в себе больше одного метода, мы можем через += и -= [добавлять методы](../../appendix/delegate.md#Добавление-методов-в-делегат) и [удалять методы](../../appendix/delegate.md#Удаление-методов-из-делегата) из списка вызовов делегата. [подробнее]()

## Лямбда-выражения
Лямбда-выражения представляют упрощенную запись анонимных методов. Лямбда-выражения позволяют создать емкие лаконичные методы, которые могут возвращать некоторое значение и которые можно передать в качестве параметров в другие методы.

С точки зрения типа данных лямбда-выражение представляет [делегат](./delegate.md). Таким образом с лямбдами можно делать всё тоже, что и с делегатами. Определим простейшее лямбда-выражение:

```C#
delegate void Message();
Message hello = () => Console.WriteLine("Hello");
hello();  // Hello
```

Если лямбда-выражение содержит несколько действий, то они помещаются в фигурные скобки:

```C#
Message hello = () =>
{
    Console.Write("Hello ");
    Console.WriteLine("World");
};
hello();  // Hello World
```

> Более подробно о [лямбдах](../../appendix/lambda.md)

## Функции обратного вызова (callback)

В компьютерном программировании **callback** — это исполняемый код, который передается в качестве аргумента другому коду. Таким образом callback-ом может быть любой делегат (лямбда). Простой пример callback-а в C#:

```C#
int[] nums = {1, 2, 3, 4};

// лямбда в качестве параметра метода Where
nums = nums.Where((num) => num % 2 == 0).ToArray();
foreach (int element in nums)
    Console.Write(element + " "); // 2 4
```


## Event (Событие)

События — это особый вид делегата, который может вызываться только из класса (или производных классов) или структуры, где они объявлены (класс издателя).

События объявляются в классе с помощью ключевого слова `event`, после которого указывается тип делегата, который представляет событие:

```C#
delegate void AccountHandler(string message);
event AccountHandler Notify;
```

У событий также могут быть обработчики, которые срабатывают когда то или иное событие происходит. Обработчики можно добавлять и удалять как обыкновенные делегаты.

```C#
void DisplayMessage(string message) => Console.WriteLine(message);
Notify += DisplayMessage;   // Добавляем обработчик для события Notify
Notify("Только сегодня и только сейчас, скидки 200% на всё...(много текста)")
// Наш обработчик перехватит событие и выведет его
```

 > Более подробно о [событиях](../../appendix/events.md)

 > Помимо нативной реализации событий в C#, есть ещё модель событий [.NET Framework](../../appendix/dot_net_events.md), которую тоже нужно понимать.

## EventHandler (Обработчик события)

Представляет метод, обрабатывающий событие с данными.

```C#
public delegate void EventHandler(object? sender, EventArgs e);
```

 - `sender` - Объект-источник события. Например, кнопка Windows Forms или ещё что-то
 - `e` - `EventArgs`. Если экземпляр класса EventArgs, то не содержит данных о событии. Если наследник, то может передавать в событии полезную информацию

Относится к модели событий [.NET Framework](../../appendix/dot_net_events.md)

## Класс Sender и классы Receivers

Под классом **Sender** подразумевается любой класс, генерирующий события.
Под классами **Receivers** подразумеваются классы, получающие события.

Класс, отправитель сообщения, в принципе, не знает своих получателей. Одно и то же сообщение может быть получено и по-разному обработано произвольным числом объектов разных классов.

## Класс EventArgs и его потомки

`EventArgs` сам по себе не содержит данных о событии. Но наследники данного класса могут передавать полезную информацию о событии. Вот определение класса `EventArgs`

```C#
public class EventArgs
{
    public static readonly EventArgs Empty;
}
```

Относится к модели событий [.NET Framework](../../appendix/dot_net_events.md)

## Класс Receiver

Получатель сообщения (события) может объявлять множественные обработчики события. Например, форма может получать события нажатых кнопок и реагировать на них как угодно. Например, если событие отправляет TextBox, мы можем запретить запись конкретного символа в него.

## Связывание обработчика с событием

Производится оператором +=. Обработчиков может быть множество.

 > [Подробнее](../../appendix/events.md#Добавление-обработчика-события)

## Отключение обработчика

Также, обработчики можно удалять через -=.

 > [Подробнее](../../appendix/events.md#Добавление-и-удаление-обработчиков)

## Динамическое связывание событий с их обработчиками

Динамическое связывание событий с их обработчиками в C# осуществляется с помощью метода += или -=. Этот метод используется для добавления или удаления обработчика события из списка обработчиков.

 > [Подробнее](../../appendix/events.md#Добавление-и-удаление-обработчиков)

