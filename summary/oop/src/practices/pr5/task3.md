# Задание 3. Создание архитектуры приложения с помощью интерфейсов

Последовательность выполнения задания следующая:

1.	Изучить возможность и преимущества создания архитектуры приложения с помощью интерфейсов.
2.	Написать в отчет о работе краткую справку об использовании абстрактных классов и интерфейсов при проектировании крупных промышленных приложений. Советуем посмотреть видеоурок https://www.youtube.com/watch?v=eXapyrhtj7I&t=111s
3.	Создать архитектуру собственного приложения с помощью интерфейсов.
Обеспечить частичную или полную реализацию классов.
В качестве примера можно выбрать: книжный магазин, расширенный блокнот для делопроизводства, интернет магазин для продажи компьютеров и т.п.
4.	Разработать и включить в отчет диаграмму UML для вашего приложения.

## Часть 1

Интерфейсы - это основной кирпичик, позволяющий использовать композицию вместо наследования. Ознакомимся с тем, что же такое эта "композиция"


### Композиция вместо наследования

#### [Википедия:](https://en.wikipedia.org/wiki/Composition_over_inheritance)

Предпочтение композиции перед наследованием - это принцип проектирования, который придает дизайну большую гибкость. Более естественно создавать классы бизнес-домена из различных компонентов, чем пытаться найти общность между ними и создавать генеалогическое древо. Например, педаль акселератора и рулевое колесо имеют очень мало общих черт, но оба являются жизненно важными компонентами автомобиля. Что они могут делать и как их можно использовать с пользой для автомобиля, легко определить. Композиция также обеспечивает более стабильную бизнес-сферу в долгосрочной перспективе, поскольку она менее подвержена причудам членов семьи. Другими словами, лучше составить то, что объект может делать (имеет-a), чем расширять то, что он есть (is-a).

Первоначальное проектирование упрощается за счет определения поведения системных объектов в отдельных интерфейсах вместо создания иерархической взаимосвязи для распределения поведения между классами бизнес-домена посредством наследования. Этот подход легче приспосабливается к будущим изменениям требований, которые в противном случае потребовали бы полной реструктуризации классов бизнес-домена в модели наследования. Кроме того, это позволяет избежать проблем, часто связанных с относительно незначительными изменениями в модели, основанной на наследовании, которая включает несколько поколений классов. Композиционное отношение более гибкое, поскольку его можно изменять во время выполнения, в то время как отношения подтипов статичны и требуют перекомпиляции на многих языках.

Некоторые языки, в частности **Go** и **Rust**, используют исключительно **type composition**.


#### Шаблоны игрового программирования. Роберт Найстром

 > Дальнейший материал данного пункта полностью взят из перевода указанной [книги](https://martalex.gitbooks.io/gameprogrammingpatterns/content/chapter-5/5.1-component.html).

Когда объектно-ориентированное программирование появилось на сцене
впервые, наследование было самым любимым из всех его инструментов. Оно
было объявлено ультимативным молотом повторного использования кода и
кодеры постоянно им размахивали. С тех пор мы на собственных ошибках
убедились в том, что этот молот может быть слишком тяжел. Наследование имеет
свое применение, но для повторного использования кода оно обычно слишком
громоздко.

Ему на замену в программирование пришел новый тренд: композиция взамен
наследования везде, где это возможно. Вместо совместного использования кода двумя
классами, которые наследуются от какого-то одного класса, мы позволяем им обеим
обладать одним и тем же экземпляром этого класса.

## Часть 2.

Возможную версию справки об использовании абстрактных классов и интерфейсов при проектировании крупных промышленных приложений можно посмотреть [тут](../../appendix/intefaces_and_abstract_classes_in_app_design.md).

## Часть 3.

Для начала определимся с идеей. Тут у нас в приоритете создание чего-то такого промышленного.
Возможные идеи:

 - книжный магазин.
 - расширенный блокнот для делопроизводства.
 - интернет магазин для продажи компьютеров.
 - http веб фреймворк.
 - веб-сервис по генерации изображений искусственным интеллектом.
 - веб-сервис по разработке дизайна приложения.
 - канбан доска.

Тут мы ограничены лишь своей фантазией.
Заметим, что сказано частично или полностью реализовать классы, что будет проблемой при создании абсолютно воображаемого приложения. 

### Возможная реализация архитектуры приложения с помощью интерфейсов (В разработке!)

Ну что же, проект делать всеравно другой в итоге, сделаем книжный магазин!

Итак, какие сущности обитают в книжном магазине? Книги?
В общем так, рассмотрим воображаемый сайт книжного магазина. Там обязательно есть кнопочка купить, 
есть страничка книги, есть поиск книг... На этом пожалуй хватит.

Пускай будет интерфейс `IBook`, пускай будет интерфейс `IForSale`, 
Из `IBook` и `IForSale` соберём книгу. 

Пускай будет интерфейс `ISearch`, который будет реализовывать возможность гибкого поиска по какой-либо коллекции, пускай будет абстрактный класс `BookCollection` который будет использовать `ISearch`.

Как-то так. План следующий:
 - Реализуем интерфейсы.
 - Собираем абстрактные классы `Book` и `IBookCollection`.
 - Собираем классы для различных жанров книг, класс коллекции книг.
 - Делаем какое-то подобие страницы магазина на WindowsForms или чём-то таком. Можно просто - значит делаем просто.



## Часть 4.

Для построения UML диаграмм любого типа рекомендуется использование [StarUML](https://staruml.io)