<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Задание 1. Написать в отчет о практической работе небольшой авторский реферат о паттернах проектирования (В разработке) - ООП практические работы 5-8</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../intro.html"><strong aria-hidden="true">1.</strong> Введение</a></li><li class="chapter-item expanded "><a href="../../practices/pr5/p5.html"><strong aria-hidden="true">2.</strong> Практическая работа №5</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../practices/pr5/key_concepts.html"><strong aria-hidden="true">2.1.</strong> Ключевые понятия</a></li><li class="chapter-item expanded "><a href="../../practices/pr5/task1.html"><strong aria-hidden="true">2.2.</strong> Задание 1. Использование интерфейсов</a></li><li class="chapter-item expanded "><a href="../../practices/pr5/task2.html"><strong aria-hidden="true">2.3.</strong> Задание 2. Создание абстрактного класса</a></li><li class="chapter-item expanded "><a href="../../practices/pr5/task3.html"><strong aria-hidden="true">2.4.</strong> Задание 3. Создание архитектуры приложения с помощью интерфейсов</a></li></ol></li><li class="chapter-item expanded "><a href="../../practices/pr6/p6.html"><strong aria-hidden="true">3.</strong> Практическая работа №6</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../practices/pr6/key_concepts.html"><strong aria-hidden="true">3.1.</strong> Ключевые понятия</a></li><li class="chapter-item expanded "><a href="../../practices/pr6/task1.html"><strong aria-hidden="true">3.2.</strong> Задание 1. Использование событий</a></li><li class="chapter-item expanded "><a href="../../practices/pr6/task2.html"><strong aria-hidden="true">3.3.</strong> Задание 2. Использование лямбда-выражений</a></li><li class="chapter-item expanded "><a href="../../practices/pr6/task3.html"><strong aria-hidden="true">3.4.</strong> Задание 3. Создание собственных событий</a></li></ol></li><li class="chapter-item expanded "><a href="../../practices/pr7/p7.html"><strong aria-hidden="true">4.</strong> Практическая работа №7</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../practices/pr7/task1.html" class="active"><strong aria-hidden="true">4.1.</strong> Задание 1. Написать в отчет о практической работе небольшой авторский реферат о паттернах проектирования (В разработке)</a></li><li class="chapter-item expanded "><a href="../../practices/pr7/task2.html"><strong aria-hidden="true">4.2.</strong> Задание 2. Реализовать 3-4 паттерна проектирования на языке программирования C# (В разработке)</a></li></ol></li><li class="chapter-item expanded "><a href="../../appendix/page.html"><strong aria-hidden="true">5.</strong> Приложение</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../appendix/vs_hotkeys.html"><strong aria-hidden="true">5.1.</strong> Visual studio хоткеи</a></li><li class="chapter-item expanded "><a href="../../appendix/interfaces.html"><strong aria-hidden="true">5.2.</strong> Интерфейсы</a></li><li class="chapter-item expanded "><a href="../../appendix/abstract_class.html"><strong aria-hidden="true">5.3.</strong> Абстрактный класс</a></li><li class="chapter-item expanded "><a href="../../appendix/multiple_interface_inherit.html"><strong aria-hidden="true">5.4.</strong> Множественное наследование</a></li><li class="chapter-item expanded "><a href="../../appendix/explicit_interfaces.html"><strong aria-hidden="true">5.5.</strong> Явная реализация интерфейсов</a></li><li class="chapter-item expanded "><a href="../../appendix/abstract_classes_vs_interfaces.html"><strong aria-hidden="true">5.6.</strong> Абстрактные классы vs интерфейсы</a></li><li class="chapter-item expanded "><a href="../../appendix/intefaces_and_abstract_classes_in_app_design.html"><strong aria-hidden="true">5.7.</strong> Справка по проектированию с использованием абстрактных классов и интерфейсов</a></li><li class="chapter-item expanded "><a href="../../appendix/delegate.html"><strong aria-hidden="true">5.8.</strong> Делегаты</a></li><li class="chapter-item expanded "><a href="../../appendix/lambda.html"><strong aria-hidden="true">5.9.</strong> Лямбда выражения</a></li><li class="chapter-item expanded "><a href="../../appendix/events.html"><strong aria-hidden="true">5.10.</strong> События и их обработчики</a></li><li class="chapter-item expanded "><a href="../../appendix/dot_net_events.html"><strong aria-hidden="true">5.11.</strong> Модель событий .NET Framework</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/main.html"><strong aria-hidden="true">5.12.</strong> Паттерны проектирования</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.1.</strong> Порождающие паттерны</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../appendix/patterns/abstract_factory.html"><strong aria-hidden="true">5.12.1.1.</strong> Абстрактная фабрика (Abstract Factory)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/builder.html"><strong aria-hidden="true">5.12.1.2.</strong> Строитель (Builder)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/factory_method.html"><strong aria-hidden="true">5.12.1.3.</strong> Фабричный метод (Factory Method)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/prototype.html"><strong aria-hidden="true">5.12.1.4.</strong> Прототип (Prototype)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/singleton.html"><strong aria-hidden="true">5.12.1.5.</strong> Одиночка (Singleton)</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.2.</strong> Структурные паттерны</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../appendix/patterns/adapter.html"><strong aria-hidden="true">5.12.2.1.</strong> Адаптер (Adapter)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/bridge.html"><strong aria-hidden="true">5.12.2.2.</strong> Мост (Bridge)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/composite.html"><strong aria-hidden="true">5.12.2.3.</strong> Компоновщик (Composite)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/decorator.html"><strong aria-hidden="true">5.12.2.4.</strong> Декоратор (Decorator)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/facade.html"><strong aria-hidden="true">5.12.2.5.</strong> Фасад (Facade)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/flyweight.html"><strong aria-hidden="true">5.12.2.6.</strong> Приспособленец (Flyweight)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/proxy.html"><strong aria-hidden="true">5.12.2.7.</strong> Заместитель (Proxy)</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.3.</strong> Поведенческие паттерны</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../appendix/patterns/chain.html"><strong aria-hidden="true">5.12.3.1.</strong> Цепочка обязанностей (Chain of responsibility)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/command.html"><strong aria-hidden="true">5.12.3.2.</strong> Команда (Command)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/interpreter.html"><strong aria-hidden="true">5.12.3.3.</strong> Интерпретатор (Interpreter)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/iterator.html"><strong aria-hidden="true">5.12.3.4.</strong> Итератор (Iterator)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/mediator.html"><strong aria-hidden="true">5.12.3.5.</strong> Посредник (Mediator)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/memento.html"><strong aria-hidden="true">5.12.3.6.</strong> Хранитель (Memento)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/observer.html"><strong aria-hidden="true">5.12.3.7.</strong> Наблюдатель (Observer)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/state.html"><strong aria-hidden="true">5.12.3.8.</strong> Состояние (State)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/strategy.html"><strong aria-hidden="true">5.12.3.9.</strong> Стратегия (Strategy)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/template_method.html"><strong aria-hidden="true">5.12.3.10.</strong> Шаблонный метод (Template method)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/visitor.html"><strong aria-hidden="true">5.12.3.11.</strong> Посетитель (Visitor).</a></li></ol></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ООП практические работы 5-8</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Задание-1-Написать-в-отчет-о-практической-работе-небольшой-авторский-реферат-о-паттернах-проектирования"><a class="header" href="#Задание-1-Написать-в-отчет-о-практической-работе-небольшой-авторский-реферат-о-паттернах-проектирования">Задание 1. Написать в отчет о практической работе небольшой авторский реферат о паттернах проектирования</a></h1>
<h1 id="ВНИМАНИЕ-ДАННАЯ-ГЛАВА-НАХОДИТСЯ-В-РАЗРАБОТКЕ"><a class="header" href="#ВНИМАНИЕ-ДАННАЯ-ГЛАВА-НАХОДИТСЯ-В-РАЗРАБОТКЕ">ВНИМАНИЕ! ДАННАЯ ГЛАВА НАХОДИТСЯ В РАЗРАБОТКЕ!</a></h1>
<p>Задание 1. Написать в отчет о практической работе небольшой авторский реферат о паттернах проектирования:</p>
<p>Описать структуры паттернов:</p>
<ol>
<li>
<p>Порождающие паттерны — паттерны, которые абстрагируют процесс инстанцирования или, иными словами, процесс порождения классов и объектов. Среди них выделяются следующие: <a href="../../appendix/patterns/abstract_factory.html">Абстрактная фабрика (Abstract Factory)</a>, <a href="../../appendix/patterns/builder.html">Строитель (Builder)</a>, <a href="../../appendix/patterns/factory_method.html">Фабричный метод (Factory Method)</a>, <a href="../../appendix/patterns/prototype.html">Прототип (Prototype)</a>, <a href="../../appendix/patterns/singleton.html">Одиночка (Singleton)</a></p>
</li>
<li>
<p>Структурные паттерны - рассматривают, как классы и объекты образуют более крупные структуры - более сложные по характеру классы и объекты. К таким шаблонам относятся: <a href="../../appendix/patterns/adapter.html">Адаптер (Adapter)</a>, <a href="../../appendix/patterns/bridge.html">Мост (Bridge)</a>, <a href="../../appendix/patterns/composite.html">Компоновщик (Composite)</a>, <a href="../../appendix/patterns/decorator.html">Декоратор (Decorator)</a>, <a href="../../appendix/patterns/facade.html">Фасад (Facade)</a>, <a href="../../appendix/patterns/flyweight.html">Приспособленец (Flyweight)</a>, <a href="../../appendix/patterns/proxy.html">Заместитель (Proxy)</a></p>
</li>
<li>
<p>Поведенческие паттерны - определяют алгоритмы и взаимодействие между классами и объектами, то есть их поведение. Среди подобных шаблонов можно выделить следующие: <a href="../../appendix/patterns/chain.html">Цепочка обязанностей (Chain of responsibility)</a>, <a href="../../appendix/patterns/command.html">Команда (Command)</a>, <a href="../../appendix/patterns/interpreter.html">Интерпретатор (Interpreter)</a>, <a href="../../appendix/patterns/iterator.html">Итератор (Iterator)</a>, <a href="../../appendix/patterns/mediator.html">Посредник (Mediator)</a>, <a href="../../appendix/patterns/memento.html">Хранитель (Memento)</a>, <a href="../../appendix/patterns/observer.html">Наблюдатель (Observer)</a>, <a href="../../appendix/patterns/state.html">Состояние (State)</a>, <a href="../../appendix/patterns/strategy.html">Стратегия (Strategy)</a>, <a href="../../appendix/patterns/template_method.html">Шаблонный метод (Template method)</a>, <a href="../../appendix/patterns/visitor.html">Посетитель  (Visitor)</a>.</p>
</li>
</ol>
<p>Включить в реферат различные точки зрения на использование паттернов, изученные вами на специализированных сайтах и форумах.</p>
<h2 id="Более-подробно-о-паттернах"><a class="header" href="#Более-подробно-о-паттернах">Более подробно о паттернах</a></h2>
<blockquote>
<p>Более подробно о паттернах можно почитать <a href="../../appendix/patterns/main.html">тут</a> или в <a href="https://yandex.ru/search/?text=%D0%BA%D0%BD%D0%B8%D0%B3%D0%B0+%D0%B1%D0%B0%D0%BD%D0%B4%D1%8B+%D1%87%D0%B5%D1%82%D1%8B%D1%80%D0%B5%D1%85+%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B+%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F+%D1%81%D0%BA%D0%B0%D1%87%D0%B0%D1%82%D1%8C&amp;lr=28676&amp;clid=9582&amp;src=suggest_T">книге банды четырёх</a></p>
</blockquote>
<h2 id="Некоторые-полезные-фразы-и-материалы-для-реферата"><a class="header" href="#Некоторые-полезные-фразы-и-материалы-для-реферата">Некоторые полезные фразы и материалы для реферата:</a></h2>
<h3 id="Из-введения-книги-банды-четырёх"><a class="header" href="#Из-введения-книги-банды-четырёх">Из введения книги банды четырёх</a></h3>
<p>Паттерны появились потому, что многие разработчики искали пути повышения гибкости и степени повторного использования своих программ<sup class="footnote-reference"><a href="#1">1</a></sup>. </p>
<p>Использование паттернов при разработке
программных систем позволяет проектировщику перейти на более высокий уровень разработки проекта. Теперь архитектор и программист могут
оперировать образными названиями паттернов и общаться на одном языке<sup class="footnote-reference"><a href="#1">1</a></sup>. </p>
<p>Прежде всего, опытный разработчик понимает, что не нужно решать каждую
новую задачу с нуля. Вместо этого он старается повторно воспользоваться 
теми решениями, которые оказались удачными в прошлом. Отыскав хорошее
решение один раз, он будет прибегать к нему снова и снова. Именно благодаря накопленному опыту проектировщик и становится экспертом в своей
области. Во многих объектно-ориентированных системах встречаются повторяющиеся паттерны, состоящие из классов и взаимодействующих объектов.
С их помощью решаются конкретные задачи проектирования, в результате
чего объектно-ориентированная архитектура становится более гибкой,
элегантной, и может использоваться повторно. Проектировщик, знакомый
с паттернами, может сразу же применять их к решению новой задачи, не
пытаясь каждый раз изобретать велосипед<sup class="footnote-reference"><a href="#1">1</a></sup>. </p>
<p>Если вы знаете паттерн,
многие проектировочные решения далее следуют автоматически<sup class="footnote-reference"><a href="#1">1</a></sup>. </p>
<p>Паттерны проектирования упрощают повторное использование удачных
проектных и архитектурных решений. Представление прошедших проверку
временем методик в виде паттернов проектирования делает их более доступными для разработчиков новых систем. Паттерны проектирования помогают
выбрать альтернативные решения, упрощающие повторное использование
системы, и избежать тех альтернатив, которые его затрудняют. Паттерны
улучшают качество документации и сопровождения существующих систем, 
поскольку они позволяют явно описать взаимодействия классов и объектов,
а также причины, по которым система была построена так, а не иначе. Проще
говоря, паттерны проектирования дают разработчику возможность быстрее
найти правильный путь<sup class="footnote-reference"><a href="#1">1</a></sup>. </p>
<h3 id="Где-то-в-книге-банды-четырёх"><a class="header" href="#Где-то-в-книге-банды-четырёх">Где-то в книге банды четырёх</a></h3>
<p>Некоторые паттерны часто используются вместе. Например, компоновщик применяется
с итератором или посетителем. Некоторыми паттернами предлагаются альтернативные решения. Так, прототип нередко можно использовать вместо
абстрактной фабрики. Применение части паттернов приводит к схожему
дизайну, хотя изначально их назначение различно. Например, структурные
диаграммы компоновщика и декоратора похожи<sup class="footnote-reference"><a href="#1">1</a></sup>. </p>
<p>Если при проектировании системы не принималась во внимание возможность изменений, то есть вероятность, что в будущем ее придется полностью перепроектировать. Это может повлечь за собой переопределение и новую реализацию классов, модификацию клиентов и повторный цикл тестирования. Перепроектирование отражается на многих частях системы, поэтому непредвиденные изменения всегда оказываются дорогостоящими.
Благодаря паттернам систему всегда можно модифицировать определенным образом<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>Паттерны помогают адаптировать архитектуру каркаса ко многим приложениям без повторного проектирования<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p><strong>Каждый паттерн позволяет изменять некоторый аспект системы независимо от всех прочих, таким образом, она менее подвержена влиянию изменений конкретного вида<sup class="footnote-reference"><a href="#1">1</a></sup>.</strong></p>
<p>Никакое обсуждение применения паттернов проектирования нельзя считать полным, если не сказать о том, как не надо их применять. Паттерны не должны применяться без разбора. Нередко за гибкость и простоту изменения, которые дают паттерны, приходится платить усложнением дизайна и/или ухудшением производительности. Паттерн проектирования стоит применять, только когда дополнительная гибкость действительно необходима<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<h3 id="Паттерны-для-каркасов-приложения"><a class="header" href="#Паттерны-для-каркасов-приложения">Паттерны для каркасов приложения</a></h3>
<p>Каркас диктует определенную архитектуру приложения. Он определяет общую структуру, ее разделение на классы и объекты, ключевые обязанности тех и других, методы взаимодействия объектов и классов и потоки управления. Данные параметры проектирования задаются каркасом, а проектировщики или разработчики приложений могут сконцентрироваться на специфике приложения. В каркасе отражены проектные решения, общие для данной предметной области. Акцент в каркасе делается на повторном использовании дизайна, а не кода, хотя обычно он включает и конкретные подклассы, которые можно применять непосредственно<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>Тот, кто знает паттерны, способен быстрее разобраться в тонкостях каркаса. Но даже не работающие с паттернами увидят их преимущества, поскольку паттерны помогают удобно структурировать документацию по каркасу. Повышение качества документирования важно для любых программных продуктов, но для каркасов этот аспект важен вдвойне. Для освоения работы с каркасами надо потратить немало усилий, и только после этого они начнут приносить реальную пользу. <strong>Паттерны могут существенно упростить задачу, явно выделяя ключевые элементы дизайна каркаса<sup class="footnote-reference"><a href="#1">1</a></sup>.</strong></p>
<h3 id="Отношения-между-паттернами-проектирования"><a class="header" href="#Отношения-между-паттернами-проектирования">Отношения между паттернами проектирования</a></h3>
<p><img src="../../appendix/patterns/images/patterns-relation.png" alt="Отношения между паттернами проектирования" /></p>
<p>Паттерны проектирования помогают выявить не вполне очевидные абстракции и объекты, которые могут их использовать. Например, объектов, представляющих процесс или алгоритм, в действительности нет, но они являются
неотъемлемыми составляющими гибкого дизайна. Паттерн стратегия (362)
описывает способ реализации взаимозаменяемых семейств алгоритмов. Паттерн состояние (352) представляет состояние некоторой сущности в виде
объекта. Эти объекты редко возникают во время анализа и даже на ранних
стадиях проектирования. Они появляются позднее, при попытках сделать
дизайн более гибким и пригодным для повторного использования<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<h3 id="Причины-перепроектирования-системы-по-сути-антипаттерны"><a class="header" href="#Причины-перепроектирования-системы-по-сути-антипаттерны">Причины перепроектирования системы (по сути, антипаттерны):</a></h3>
<ul>
<li>
<p>При создании объекта явно указывается класс. Задание имени класса привязывает вас к конкретной реализации, а не к конкретному интерфейсу. Это может осложнить изменение объекта в будущем. Чтобы уйти от такой проблемы, создавайте объекты косвенно. Паттерны проектирования: абстрактная фабрика (113), фабричный метод (135), прототип (146)<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
</li>
<li>
<p>Зависимость от конкретных операций. Задавая конкретную операцию, вы ограничиваете себя единственным способом выполнения запроса. Если же не включать запросы в код, то будет проще изменить способ удовлетворения запроса как на этапе компиляции, так и на этапе выполнения. Паттерны проектирования: цепочка обязанностей (263), команда (275)<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
</li>
<li>
<p>Зависимость от аппаратной и программной платформ. Внешние интерфейсы операционной системы и интерфейсы прикладных программ (API) различны на разных программных и аппаратных платформах. Если программа зависит от конкретной платформы, ее будет труднее перенести на другие. Возможно, даже на «родной» платформе такую программу трудно поддерживать. Поэтому при проектировании систем так важно ограничивать платформенные зависимости. Паттерны проектирования: абстрактная фабрика (113), мост (184)<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
</li>
<li>
<p>Зависимость от представления или реализации объекта. Если клиент располагает информацией о том, как объект представлен, хранится или реализован, то, возможно, при изменении объекта придется изменять и клиента. Сокрытие этой информации от клиентов поможет уберечься от каскадных изменений. Паттерны проектирования: абстрактная фабрика (113), мост (184), хранитель (330), заместитель (246)<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
</li>
<li>
<p>Зависимость от алгоритмов. Во время разработки и последующего использования алгоритмы часто расширяются, оптимизируются и заменяются. Зависящие от алгоритмов объекты придется переписывать при каждом изменении алгоритма. Поэтому алгоритмы, которые с большой вероятностью будут изменяться, следует изолировать. Паттерны проектирования: мост (184), итератор (302), стратегия (362), шаблонный метод (373), посетитель (379)<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
</li>
<li>
<p>сильная связанность. Сильно связанные между собой классы трудно использовать порознь, так как они зависят друг от друга. Сильная связанность приводит к появлению монолитных систем, в которых нельзя ни изменить, ни удалить класс без знания деталей и модификации других классов. Такую систему трудно изучать, переносить на другие платформы и сопровождать<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
</li>
</ul>
<p>Слабая связанность повышает вероятность того, что класс можно будет повторно использовать сам по себе. При этом изучение, перенос, модификация и сопровождение системы намного упрощаются. Для поддержки слабосвязанных систем в паттернах проектирования применяются такие методы, как абстрактные связи и разбиение на слои.
Паттерны проектирования: абстрактная фабрика (113), мост (184), цепочка обязанностей (263), команда (275), фасад (221), посредник (319), наблюдатель (339)<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<ul>
<li>
<p>расширение функциональности за счет порождения подклассов. Специализация объекта путем создания подкласса часто оказывается непростым делом. С каждым новым подклассом связаны фиксированные издержки реализации (инициализация, очистка и т. д.). Для определения подкласса необходимо так же ясно представлять себе устройство родительского класса. Например, замещение одной операции может потребовать замещения и других. Замещение операции может оказаться необходимым для того, чтобы можно было вызвать унаследованную операцию. Кроме того, порождение подклассов ведет к разрастанию количества классов, поскольку даже для реализации простого расширения приходится создавать новые подклассы. Композиция объектов и делегирование — гибкие альтернативы наследованию для комбинирования поведений. Приложению можно добавить новую функциональность, меняя способ композиции объектов, а не определяя новые подклассы уже имеющихся классов. С другой стороны, интенсивное использование композиции объектов может усложнить понимание кода. С помощью многих паттернов проектирования удается построить такое решение, где специализация достигается за счет определения одного подкласса и комбинирования его экземпляров с уже существующими. Паттерны проектирования: мост (184), цепочка обязанностей (263), компоновщик (196), декоратор (209), наблюдатель (339), стратегия (362)<sup class="footnote-reference"><a href="#1">1</a></sup>. </p>
</li>
<li>
<p>неудобства при изменении классов. Иногда нужно модифицировать класс, но делать это неудобно. Допустим, вам нужен исходный код, а он недоступен (так обстоит дело с коммерческими библиотеками классов). Или любое изменение тянет за собой модификации множества существующих подклассов. Благодаря паттернам проектирования можно модифицировать классы и при таких условиях.
Паттерны проектирования: адаптер (171), декоратор (209), посетитель (379)<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
</li>
</ul>
<h3 id="Приложения"><a class="header" href="#Приложения">Приложения</a></h3>
<p>Если вы проектируете приложения — например, редактор документов или электронную таблицу, — то наивысший приоритет имеют внутреннее повторное использование, удобство сопровождения и расширяемость. Первое подразумевает, что вы не проектируете и не реализуете больше, чем необходимо. Повысить степень внутреннего повторного использования помогут паттерны, уменьшающие число зависимостей. Ослабление связанности увеличивает вероятность того, что некоторый класс объектов сможет взаимодействовать с другими. Например, устраняя зависимости от конкретных операций путем изолирования и инкапсуляции каждой операции, вы упрощаете задачу повторного использования любой операции в другом контексте. К тому же результату приводит устранение зависимостей от алгоритма и представления<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>Паттерны проектирования также упрощают сопровождение приложения, если использовать их для ограничения платформенных зависимостей и разбиения системы на уровни. Они способствуют и наращиванию функциональности системы, показывая, как расширять иерархии классов и когда следует применять композицию объектов. Уменьшение степени связанности также увеличивает возможность развития системы. Расширение класса становится проще, если он не зависит от множества других<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<h3 id="Аспекты-дизайна-которые-могут-изменяться-при-применении-паттернов-проектирования"><a class="header" href="#Аспекты-дизайна-которые-могут-изменяться-при-применении-паттернов-проектирования">Аспекты дизайна, которые могут изменяться при применении паттернов проектирования</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Назначение</th><th>Паттерн проектирования</th><th>Переменные аспекты</th></tr></thead><tbody>
<tr><td>Порождающие паттерны</td><td>Абстрактная фабрика (113)</td><td>Семейства порождаемых объектов</td></tr>
<tr><td></td><td>Одиночка (157)</td><td>Единственный экземпляр класса</td></tr>
<tr><td></td><td>Прототип (146)</td><td>Класс, на основе которого создается объект</td></tr>
<tr><td></td><td>Строитель (124)</td><td>Способ создания составного объекта</td></tr>
<tr><td></td><td>Фабричный метод (135)</td><td>Подкласс создаваемого объекта</td></tr>
<tr><td>Структурные паттерны</td><td>Адаптер (171)</td><td>Интерфейс к объекту</td></tr>
<tr><td></td><td>Декоратор (209)</td><td>Обязанности объекта без порождения подкласса</td></tr>
<tr><td></td><td>Заместитель (246)</td><td>Способ доступа к объекту, его местоположение</td></tr>
<tr><td></td><td>Компоновщик (196)</td><td>Структура и состав объекта</td></tr>
<tr><td></td><td>Мост (184)</td><td>Реализация объекта</td></tr>
<tr><td></td><td>Приспособленец (231)</td><td>Затраты на хранение объектов</td></tr>
<tr><td></td><td>Фасад (221)</td><td>Интерфейс к подсистеме</td></tr>
<tr><td>Паттерны поведения</td><td>Интерпретатор (287)</td><td>Грамматика и интерпретация языка</td></tr>
<tr><td></td><td>Итератор (302)</td><td>Способ перебора элементов агрегата</td></tr>
<tr><td></td><td>Команда (275)</td><td>Время и способ выполнения запроса</td></tr>
<tr><td></td><td>Наблюдатель (339)</td><td>Множество объектов, зависящих от другого объекта; способ, которым зависимые объекты поддерживают себя в актуальном состоянии</td></tr>
<tr><td></td><td>Посетитель (379)</td><td>Операции, которые могут применяться к объекту или объектам, не меняя класса</td></tr>
<tr><td></td><td>Посредник (319)</td><td>Взаимодействующие объекты и механизм их совместной работы</td></tr>
<tr><td></td><td>Состояние (352)</td><td>Состояние объекта</td></tr>
<tr><td></td><td>Стратегия (362)</td><td>Алгоритм</td></tr>
<tr><td></td><td>Хранитель (330)</td><td>Закрытая информация, хранящаяся вне объекта, и время ее сохранения</td></tr>
<tr><td></td><td>Цепочка обязанностей (263)</td><td>Объект, выполняющий запрос</td></tr>
<tr><td></td><td>Шаблонный метод (373)</td><td>Шаги алгоритма</td></tr>
</tbody></table>
</div>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Книга банды четырёх.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../practices/pr7/p7.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../practices/pr7/task2.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../practices/pr7/p7.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../practices/pr7/task2.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
