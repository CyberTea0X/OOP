<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ООП практические работы 5-8</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Введение</a></li><li class="chapter-item expanded "><a href="practices/pr5/p5.html"><strong aria-hidden="true">2.</strong> Практическая работа №5</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="practices/pr5/key_concepts.html"><strong aria-hidden="true">2.1.</strong> Ключевые понятия</a></li><li class="chapter-item expanded "><a href="practices/pr5/task1.html"><strong aria-hidden="true">2.2.</strong> Задание 1. Использование интерфейсов</a></li><li class="chapter-item expanded "><a href="practices/pr5/task2.html"><strong aria-hidden="true">2.3.</strong> Задание 2. Создание абстрактного класса</a></li><li class="chapter-item expanded "><a href="practices/pr5/task3.html"><strong aria-hidden="true">2.4.</strong> Задание 3. Создание архитектуры приложения с помощью интерфейсов</a></li></ol></li><li class="chapter-item expanded "><a href="practices/pr6/p6.html"><strong aria-hidden="true">3.</strong> Практическая работа №6</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="practices/pr6/key_concepts.html"><strong aria-hidden="true">3.1.</strong> Ключевые понятия</a></li><li class="chapter-item expanded "><a href="practices/pr6/task1.html"><strong aria-hidden="true">3.2.</strong> Задание 1. Использование событий (в разработке)</a></li></ol></li><li class="chapter-item expanded "><a href="appendix/page.html"><strong aria-hidden="true">4.</strong> Приложение</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/vs_hotkeys.html"><strong aria-hidden="true">4.1.</strong> Visual studio хоткеи</a></li><li class="chapter-item expanded "><a href="appendix/interfaces.html"><strong aria-hidden="true">4.2.</strong> Интерфейсы</a></li><li class="chapter-item expanded "><a href="appendix/abstract_class.html"><strong aria-hidden="true">4.3.</strong> Абстрактный класс</a></li><li class="chapter-item expanded "><a href="appendix/multiple_interface_inherit.html"><strong aria-hidden="true">4.4.</strong> Множественное наследование</a></li><li class="chapter-item expanded "><a href="appendix/explicit_interfaces.html"><strong aria-hidden="true">4.5.</strong> Явная реализация интерфейсов</a></li><li class="chapter-item expanded "><a href="appendix/abstract_classes_vs_interfaces.html"><strong aria-hidden="true">4.6.</strong> Абстрактные классы vs интерфейсы</a></li><li class="chapter-item expanded "><a href="appendix/intefaces_and_abstract_classes_in_app_design.html"><strong aria-hidden="true">4.7.</strong> Справка по проектированию с использованием абстрактных классов и интерфейсов</a></li><li class="chapter-item expanded "><a href="appendix/delegate.html"><strong aria-hidden="true">4.8.</strong> Делегаты</a></li><li class="chapter-item expanded "><a href="appendix/lambda.html"><strong aria-hidden="true">4.9.</strong> Лямбда выражения</a></li><li class="chapter-item expanded "><a href="appendix/events.html"><strong aria-hidden="true">4.10.</strong> События и их обработчики</a></li><li class="chapter-item expanded "><a href="appendix/dot_net_events.html"><strong aria-hidden="true">4.11.</strong> Модель событий .NET Framework</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ООП практические работы 5-8</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Введение"><a class="header" href="#Введение">Введение</a></h1>
<p>Данный конпект-гайд это сокращённая и упрощённая версия методички по 5-8 работам с теорией и пояснениями как и что именно нужно делать на русском языке.</p>
<p>Будьте внимательны при копировании, так как я часто вставляю свой код, который писал сам. Обычно, из контекста понятно, когда можно спокойно скопировать код, а когда его нужно написать самим. </p>
<p>Чтобы понимать какие обновления вышли у конспекта, просто смотрите пуши в github. Так как у конспекта настроен автодеплой, любой пуш в директорию OOP/summary/oop обновляет сайт автоматически.</p>
<p><sub>А ещё можно просто смотреть на навигацию слева, но это так, слишком просто.</sub></p>
<p><a href="https://vk.com/tolya77m">Вк автора</a></p>
<p><a href="https://rust-lang.github.io/mdBook/index.html">Инструмент которым всё это делалось</a></p>
<p><a href="https://github.com/CyberTea0X/OOP">Github</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Практическая-работа-5"><a class="header" href="#Практическая-работа-5">Практическая работа №5</a></h1>
<h2 id="Тема-Наследование-классов-и-использование-интерфейсов"><a class="header" href="#Тема-Наследование-классов-и-использование-интерфейсов">Тема: Наследование классов и использование интерфейсов</a></h2>
<p><strong>Цель работы:</strong> Научиться на практике наследовать классы и интерфейсы. Разобраться на практике с вопросами отличия интерфейсов и абстрактных классов, реализовать множественное наследование интерфейсов и явную реализация интерфейсов. Научиться строить архитектуру приложения с помощью интерфейсов, разобраться с преимуществами такого подхода при промышленном программировании.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Ключевые-понятия"><a class="header" href="#Ключевые-понятия">Ключевые понятия</a></h1>
<ul>
<li><a href="practices/pr5/key_concepts.html#%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81">Интерфейс</a></li>
<li><a href="practices/pr5/key_concepts.html#%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D1%8B%D0%B9-%D0%BA%D0%BB%D0%B0%D1%81%D1%81">Абстрактный класс</a></li>
<li><a href="practices/pr5/key_concepts.html#%D0%9C%D0%BD%D0%BE%D0%B6%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%BE%D0%B2">Множественное наследование интерфейсов</a></li>
<li><a href="practices/pr5/key_concepts.html#%D0%AF%D0%B2%D0%BD%D0%B0%D1%8F-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%BE%D0%B2">Явная реализация интерфейсов</a></li>
</ul>
<h2 id="Интерфейс"><a class="header" href="#Интерфейс">Интерфейс</a></h2>
<p>Интерфейс представляет ссылочный тип, который может определять некоторый функционал - набор методов и свойств без реализации. Затем этот функционал реализуют классы и структуры, которые применяют данные интерфейсы.
Для определения интерфейса используется ключевое слово <code>interface</code>. Как правило, названия интерфейсов в C# начинаются с заглавной буквы I, например, <code>IComparable</code>, <code>IEnumerable</code> (так называемая венгерская нотация), однако это не обязательное требование, а больше стиль программирования.</p>
<pre><code class="language-C#">interface IMovable
{
    // константа
    const int minSpeed = 0;     // минимальная скорость
    // статическая переменная
    static int maxSpeed = 60;   // максимальная скорость
    // метод
    void Move();                // движение
    // свойство
    string Name { get; set; }   // название
     
    delegate void MoveHandler(string message);  // определение делегата для события
    // событие
    event MoveHandler MoveEvent;    // событие движения
}
</code></pre>
<blockquote>
<p>Более подробно об <a href="practices/pr5/../../appendix/interfaces.html">интерфейсах</a></p>
</blockquote>
<h2 id="Абстрактный-класс"><a class="header" href="#Абстрактный-класс">Абстрактный класс</a></h2>
<p>Абстрактные классы в C#. Для абстрактного класса такое создание объекта через new невозможно, т.к. абстрактный класс - это шаблон или базовый класс, который предназначен для наследования другими классами.
У абстрактных классов могут быть как абстрактные методы (методы без реализации), так и не абстрактные методы. Если у класса есть хотя бы один абстрактный метод, то он должен быть объявлен как абстрактный.
Абстрактные классы могут использоваться в ситуациях, когда вы хотите определить набор общих поведений или свойств, которые должны быть реализованы производными классами. Делая это, вы можете обеспечить согласованный интерфейс для всех классов, которые наследуются от него.</p>
<pre><code class="language-C#">abstract class Transport
{
    public void Move()
    {
        Console.WriteLine(&quot;Транспортное средство движется&quot;);
    }
}
</code></pre>
<blockquote>
<p>Более подробно об <a href="practices/pr5/../../appendix/abstract_class.html">абстрактных классах</a></p>
</blockquote>
<h2 id="Множественное-наследование-интерфейсов"><a class="header" href="#Множественное-наследование-интерфейсов">Множественное наследование интерфейсов</a></h2>
<p>Множественное наследование относится к способности класса наследовать от нескольких базовых классов. C # не поддерживает множественное наследование классов, но он поддерживает множественное наследование с использованием интерфейсов. Это может быть полезно, когда нам нужно реализовать несколько абстракций и наследовать их свойства и методы.</p>
<pre><code class="language-C#">public interface I1
{
    void Method1();
}

public interface I2
{
    void Method2();
}

public interface I3
{
    void Method3();
}

public class MyClass : I1, I2, I3
{
    public void Method1()
    {
        Console.WriteLine(&quot;Method1 called&quot;);
    }

    public void Method2()
    {
        Console.WriteLine(&quot;Method2 called&quot;);
    }

    public void Method3()
    {
        Console.WriteLine(&quot;Method3 called&quot;);
    }
}
</code></pre>
<blockquote>
<p>Более подробно о <a href="practices/pr5/../../appendix/multiple_interface_inherit.html">множественном наследовании</a></p>
</blockquote>
<h2 id="Явная-реализация-интерфейсов"><a class="header" href="#Явная-реализация-интерфейсов">Явная реализация интерфейсов</a></h2>
<p>Если класс реализует два интерфейса, а интерфейсы содержат одинаковые методы, то возникает необходимость в явной реализации интерфейсов. Сначала рассмотрим проблемный код.</p>
<pre><code class="language-C#">// Определим интерфейсы
public interface IControl
{
    void Paint();
}
public interface ISurface
{
    void Paint();
}
// Попробуем их реализовать стандартным способом
public class SampleClass : IControl, ISurface
{
    // Оба ISurface.Paint и IControl.Paint вызывают данный метод
    public void Paint()
    {
        Console.WriteLine(&quot;Paint method in SampleClass&quot;);
    }
}
SampleClass sample = new SampleClass();
IControl control = sample;
ISurface surface = sample;

// Все эти строки вызовут один и тот же метод.
sample.Paint();
control.Paint();
surface.Paint();

// Вывод (О нет, он одинаковый):
// Paint method in SampleClass
// Paint method in SampleClass
// Paint method in SampleClass
</code></pre>
<p>А теперь, явная реализация. Сравните с кодом класса <code>SampleClass</code> выше, чтобы понять разницу.</p>
<pre><code class="language-C#">public class SampleClass : IControl, ISurface
{
    void IControl.Paint() // [интерфейс].[метод]
    {
        System.Console.WriteLine(&quot;IControl.Paint&quot;);
    }
    void ISurface.Paint() // Так и выглядит явная реализация интерфейсов
    {
        System.Console.WriteLine(&quot;ISurface.Paint&quot;);
    }
}
SampleClass sample = new SampleClass();
IControl control = sample;
ISurface surface = sample;

// Все эти строки вызовут один и тот же метод.
//sample.Paint(); // Compiler error.
control.Paint();  // Вызовет IControl.Paint на SampleClass.
surface.Paint();  // Вызовет ISurface.Paint на SampleClass.

// Вывод:
// IControl.Paint
// ISurface.Paint
</code></pre>
<blockquote>
<p>Более подробно о <a href="practices/pr5/../../appendix/explicit_interfaces.html">явной реализации интерфейсов</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Задание-1-Использование-интерфейсов"><a class="header" href="#Задание-1-Использование-интерфейсов">Задание 1. Использование интерфейсов</a></h1>
<h2 id="Содержание"><a class="header" href="#Содержание">Содержание:</a></h2>
<ul>
<li>Интерфейс: <a href="practices/pr5/task1.html#%D0%A7%D0%B0%D1%81%D1%82%D1%8C-11">Часть 1.1</a></li>
<li>Перечисление: <a href="practices/pr5/task1.html#%D0%A7%D0%B0%D1%81%D1%82%D1%8C-12">Часть 1.2</a></li>
<li>Измерительное устройство: <a href="practices/pr5/task1.html#%D0%A7%D0%B0%D1%81%D1%82%D1%8C-13">Часть 1.3</a></li>
<li>Внешний вид программы: <a href="practices/pr5/task1.html#%D0%A7%D0%B0%D1%81%D1%82%D1%8C-14">Часть 1.4</a></li>
</ul>
<p>Для начала создадим новый проект с графическим интерфейсом, например, так выглядит создание проекта с Windows Forms:</p>
<p><img src="practices/pr5/../../global/images/win-forms-app-creation.png" alt="Скриншот создания проекта" /></p>
<h2 id="Часть-11"><a class="header" href="#Часть-11">Часть 1.1</a></h2>
<p>Теперь добавим в новый элемент нажатием <strong>Ctrl+Shift+A</strong>, в котором мы будем хранить наш интерфейс измерительного прибора. Назовём его <code>MeasuringDevice.cs</code></p>
<p>Cкопируем код с методички, кстати, с переведённой документацией. Вот как должен выглядить файл после копирования:</p>
<blockquote>
<p>p.s там есть кнопочка справа вверху кодового блока, можно не выделять</p>
</blockquote>
<h3 id="imeasuringdevice"><a class="header" href="#imeasuringdevice">IMeasuringDevice</a></h3>
<pre><code class="language-C#">namespace MeasuringDevice
{
    public interface IMeasuringDevice
    {
        /// &lt;summary&gt;
        /// Преобразует необработанные данные, собранные устройством измерения, в значение в метрических единицах.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Последнее измерение устройства преобразовано в метрические единицы.&lt;/returns&gt;
        decimal MetricValue();

        /// &lt;summary&gt;
        /// Преобразует необработанные данные, собранные устройством измерения, в значение в имперических единицах.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Последнее измерение устройства преобразовано в имперические единицы.&lt;/returns&gt;
        decimal ImperialValue();

        /// &lt;summary&gt;
        /// Запускает сбор данных устройства измерения.
        /// &lt;/summary&gt;
        void StartCollecting();

        /// &lt;summary&gt;
        /// Останавливает сбор данных устройства измерения.
        /// &lt;/summary&gt;
        void StopCollecting();

        /// &lt;summary&gt;
        /// Предоставляет доступ к необработанным данным, собранным устройством измерения, в любых единицах, используемых устройством.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Необработанные данные, собранные устройством измерения, в их сыром формате.&lt;/returns&gt;
        int[] GetRawData();
    }
}
</code></pre>
<h2 id="Часть-12"><a class="header" href="#Часть-12">Часть 1.2</a></h2>
<p>Теперь нужно создать перечисление <code>Units</code>, которое описывает выбранную систему измерения (метрическая или империческая). Добавим новый элемент нажатием <strong>Ctrl+Shift+A</strong> и назовём его <code>UnitsEnumeration.cs</code>. Нам нужно объявить перечисление через ключевое слово <code>enum</code>, затем назвать  его <code>Units</code>. Членами перечисления должны быть <code>Metric</code> и <code>Imperial</code>. Также, можно добавить комментарии.</p>
<p>Вот как выглядит моя реализация этого перечисления:</p>
<h3 id="units"><a class="header" href="#units">Units</a></h3>
<pre><code class="language-C#">namespace UnitsEnumeration
{
    /// &lt;summary&gt;
    /// Перечисление, которое используется для указания системы измерения.
    /// &lt;/summary&gt;
    public enum Units
    {
        Metric,
        Imperial
    }
}
</code></pre>
<h2 id="Часть-13"><a class="header" href="#Часть-13">Часть 1.3</a></h2>
<p>Далее создадим класс <code>MeasureLengthDevice</code>, где нам нужно будет реализовать интерфейс <code>IMeasuringDevice</code>. Для этого создадим файл <code>MeasureLengthDevice.cs</code> где этот класс и определим, также нам нужно установить уровень доступа public:</p>
<pre><code class="language-C#">namespace WinFormsApp1
{
    public class MeasureLengthDevice
    {
    }
}
</code></pre>
<p>Теперь добавим наследование от нашего интерфейса <a href="practices/pr5/task1.html#imeasuringdevice"><code>IMeasuringDevice</code></a></p>
<pre><code class="language-C#">using MeasuringDevice;

namespace WinFormsApp1
{
    public class MeasureLengthDevice: IMeasuringDevice
    {
    }

}
</code></pre>
<p>Теперь необходимо использовать мастер реализации интерфейса для создания заглушек методов для каждого из методов в интерфейсе IMeasuringDevice.</p>
<p>Для этого нажимаем <strong>(CTRL + '.')</strong>, после чего нажимаем <strong>Реализовать интерфейс</strong>. В итоге мы получаем класс с заглушками под методы интерфейса:</p>
<pre><code class="language-C#">// ...
namespace WinFormsApp1
{
    public class MeasureLengthDevice : IMeasuringDevice
    {
        public int[] GetRawData()
        {
            throw new NotImplementedException();
        }

        public decimal ImperialValue()
        {
            throw new NotImplementedException();
        }

        public decimal MetricValue()
        {
            throw new NotImplementedException();
        }

        public void StartCollecting()
        {
            throw new NotImplementedException();
        }

        public void StopCollecting()
        {
            throw new NotImplementedException();
        }
    }

}
</code></pre>
<p>Теперь нам надо добавить перечисление DeviceType и класс DeviceController.
Поместим их в отдельные файлы, начнём с перечисления. Жмём <strong>Ctrl+Shift+A</strong></p>
<p>DeviceType должен быть перечислением, состоящим из <code>LENGTH</code> и <code>MASS</code>.
Вот примерная реализация данного перечисления:</p>
<h3 id="devicetype"><a class="header" href="#devicetype">DeviceType</a></h3>
<pre><code class="language-C#">namespace DeviceTypeNS
{
    public enum DeviceType
    {
        LENGTH,
        MASS
    }
}
</code></pre>
<p>Далее снова жмём <strong>Ctrl+Shift+A</strong> и добавляем класс DeviceController.
Класс пока что оставим пустым, вернёмся к нему позже.</p>
<pre><code class="language-C#">namespace DeviceControllerNS
{
    public class DeviceController
    {
    }
}
</code></pre>
<p>Теперь нужно вернуться к классу MeasureLengthDevice. В него нужно добавить поля из указанной таблицы:</p>
<div class="table-wrapper"><table><thead><tr><th>Модификатор доступа</th><th>Тип</th><th>Название</th></tr></thead><tbody>
<tr><td>private</td><td>Units</td><td>unitsToUse</td></tr>
<tr><td>private</td><td>int[]</td><td>dataCaptured</td></tr>
<tr><td>private</td><td>int</td><td>mostRecentMeasure</td></tr>
<tr><td>private</td><td>DeviceController</td><td>controller</td></tr>
<tr><td>private</td><td>DeviceType</td><td>measurementType</td></tr>
</tbody></table>
</div>
<p>Примерно так теперь должен выглядить класс после добавления полей:</p>
<pre><code class="language-C#">using MeasuringDevice;
using UnitsEnumeration;
using DeviceControllerNS;
using DeviceTypeNS;

namespace WinFormsApp1
{
    public class MeasureLengthDevice : IMeasuringDevice
    {
        private Units unitsToUse;
        private int[] dataCaptured;
        private int mostRecentMeasure;
        private DeviceController controller;
        private DeviceType measurementType;
        public int[] GetRawData()
        {
            throw new NotImplementedException();
        }

        public decimal ImperialValue()
        {
            throw new NotImplementedException();
        }

        public decimal MetricValue()
        {
            throw new NotImplementedException();
        }

        public void StartCollecting()
        {
            throw new NotImplementedException();
        }

        public void StopCollecting()
        {
            throw new NotImplementedException();
        }
    }

}
</code></pre>
<p>Изменим поле measurementType, сделав его константным и инициализируем его как <code>DeviceType.LENGTH</code></p>
<pre><code class="language-C#">//...
public class MeasureLengthDevice : IMeasuringDevice
    {
        //...
        private const DeviceType measurementType = DeviceType.LENGTH;
        //...
    }
//...
</code></pre>
<p>Теперь нам нужно найти метод <code>StartCollecting</code>, а затем удалить тело метода по умолчанию, которое вставляет Visual Studio, что создает исключение <code>NotImplementedException</code>, добавить в метод <code>StartCollecting</code> код для создания экземпляра поля контроллера с помощью статического метода <code>StartDevice</code> класса <code>DeviceController</code>. Для этого нужно передать значение в поле MeasurementType в качестве параметра методу <code>StartCollecting</code>.</p>
<p>Кстати класс <code>DeviceController</code> у нас пуст, так что вернёмся к нему и придумаем
метод <code>StartDevice</code>. Ещё раз напомню что он из себя представляет: берёт <code>MeasurmentType</code> в качестве параметра, возвращает <code>DeviceController</code>.</p>
<p>Возможная реализация:</p>
<pre><code class="language-C#">using DeviceTypeNS;
namespace DeviceControllerNS
{
    public class DeviceController
    {
        DeviceType measurementType;

        public DeviceController(DeviceType measurementType)
        {
            this.measurementType = measurementType;
        }

        public static DeviceController StartDevice(DeviceType measurementType)
        {
            return new DeviceController(measurementType);
        }
    }
}
// Meow
</code></pre>
<p>Вернёмся обратно в <code>MeasureLengthDevice</code>. Нам нужно найти метод <code>StartCollecting</code>, а затем удалить тело метода по умолчанию, после чего добавить в метод <code>StartCollecting</code> код для создания экземпляра поля контроллера с помощью статического метода <code>StartDevice</code> класса <code>DeviceController</code>. Для этого нужно передать значение в поле MeasurementType в качестве параметра методу <code>StartCollecting</code>.</p>
<pre><code class="language-C#">//...
public void StartCollecting()
{
    controller = DeviceController.StartDevice(measurementType);
}
//...
</code></pre>
<p>Теперь нам надо добавить метод <code>GetMeasurements</code>, его можно просто скопировать.</p>
<h3 id="getmeasurements"><a class="header" href="#getmeasurements">GetMeasurements</a></h3>
<pre><code class="language-C#">private void GetMeasurements()
{
    dataCaptured = new int[10];
    System.Threading.ThreadPool.QueueUserWorkItem((dummy) =&gt;
    {
        int x = 0;
        Random timer = new Random();
 
        while (controller != null)
        {
            System.Threading.Thread.Sleep(timer.Next(1000, 5000));
            dataCaptured[x] = controller != null ?
                controller.TakeMeasurement() : dataCaptured[x];
            mostRecentMeasure = dataCaptured[x]; 
            x++;
            if (x == 10)
            {
                x = 0;
            }
        }
    });
}
</code></pre>
<p>Заметили эту волнистую красную линию? Нажмите туда, а затем нажмите <strong>(CTRL + '.'</strong>).
Затем нажмите создать метод <strong>TakeMeasurment</strong>. Линия пропадёт, но это ещё не всё.
Наводимся на метод, нажимаем <strong>DeviceController</strong>, таким образом переходим к определению этого класса.
Если не поняли мои махинации с хоткеями и остальным, то просто перейдите к классу <code>DeviceController</code>.</p>
<p>Найдём вот такой метод:</p>
<pre><code class="language-C#">//...
internal int TakeMeasurement()
{
    throw new NotImplementedException();
}
//...
</code></pre>
<p>Visual Studio заботливо написал для нас тип возвращаемого значения <code>int</code> и заглушку.
Наша задача вместо заглушки возвращать какое-то число...</p>
<p>Моя реализация:</p>
<h3 id="takemeasurement"><a class="header" href="#takemeasurement">TakeMeasurement</a></h3>
<pre><code class="language-C#">//...
public int TakeMeasurement()
{
    Random random = new Random();
    return random.Next(1, 10);
}
//...
</code></pre>
<p>Продолжим путешествовать по коду. Теперь вернёмся к нашему классу <code>MeasureLengthDevice</code>.
Вообще, метод <a href="practices/pr5/task1.html#getmeasurements">GetMeasurments</a> призван эмулировать работу некоторого устройства,
которое производит замеры. Так что нам нужно добавить вызов этого метода в методе <code>StartCollecting</code></p>
<pre><code class="language-C#">//...
public void StartCollecting()
{
    controller = DeviceController.StartDevice(measurementType);
    GetMeasurements();
}
//...
</code></pre>
<p>Мы будем использовать код метода GetMeasurements для заполнения массива dataCaptured. Этот массив действует как циклический буфер фиксированной длины, перезаписывая самое старое значение каждый раз при выполнении нового измерения. Далее мы изменим этот класс, чтобы он реагировал на события, которые устройство вызывает всякий раз, когда оно обнаруживает новое измерение.</p>
<p>Найдём метод StopCollecting, а затем удалим тело метода по умолчанию, которое вставляет Visual Studio, что создает исключение NotImplementedException. Добавим условный блок кода, который запускается только в том случае, если объект <code>controller</code> не равен <code>null</code>.</p>
<pre><code class="language-C#">//...
public void StopCollecting()
{
    if (controller != null)
    {

    }
}
//...
</code></pre>
<p>В условном блоке кода добавим код для вызова метода StopDevice объекта контроллера, а затем установим для поля контроллера значение <code>null</code>.</p>
<pre><code class="language-C#">//...
public void StopCollecting()
{
    if (controller != null)
    {
        controller.StopDevice();
        controller = null;
    }
}
//...
</code></pre>
<p><code>controller</code> подчёркивается зелёной волнистой линией. VS studio говорит, что <code>controller</code> не может быть
<code>null</code>. Таким образом надо слегка изменить наше поле.</p>
<pre><code class="language-C#">//...
private int mostRecentMeasure;
private DeviceController? controller;  //*
private const DeviceType measurementType = DeviceType.LENGTH;
//...
</code></pre>
<p>А ещё, пора избавится от красной линии в <code>StopCollecting</code>. <strong>(CTRL + '.')</strong>, создать метод <strong>StopDevice</strong>.
Переместимся в класс <code>DeviceController</code> и реализуем метод <code>StopDevice</code>.</p>
<p>Лично я поменял много кода. Вот возможная реализация класса <code>DeviceController</code>:</p>
<pre><code class="language-C#">using DeviceTypeNS;

namespace DeviceControllerNS
{
    public class DeviceController
    {
        DeviceType measurementType;
        bool isStopped;  // Новый код

        public DeviceController(DeviceType measurementType)
        {
            this.measurementType = measurementType;
            this.isStopped = false;  // Новый код
        }

        public static DeviceController StartDevice(DeviceType measurementType)
        {
            return new DeviceController(measurementType);
        }

        public void StopDevice()
        {
            this.isStopped = true;  // Новый код
        }

        public int TakeMeasurement()
        {
            if (!this.isStopped)  // Новый код
            {
                Random random = new Random();
                return random.Next(1, 10);
            }
            throw new Exception(&quot;Устройство остановлено, однако, была попытка сделать измерение&quot;);  // Новый код
        }
    }
}
</code></pre>
<p>Возвращаемся к классу <code>MeasureLengthDevice</code></p>
<p>Найдём метод <code>GetRawData</code>, а затем удалим тело метода по умолчанию, которое вставляет Visual Studio, что создает исключение <code>NotImplementedException</code>. Добавим код для возврата массива <code>dataCaptured</code>.</p>
<p>Возможная реализация метода:</p>
<pre><code class="language-C#">//...
public int[] GetRawData()
{
    return dataCaptured;
}
//...
</code></pre>
<p>Найдём метод <code>MetricValue</code>, а затем удалим тело метода по умолчанию. Добавим код для проверки <code>unitsToUse</code> и, если они метрические, вернём значение из поля <code>mostRecentMeasure</code>. Если текущие единицы измерения эмпирические, вернём результат умножения поля <code>mostRecentMeasure</code> на 25,4.</p>
<p>Возможная реализация метода <code>MetricValue</code>:</p>
<pre><code class="language-C#">//...
public decimal MetricValue()
{
    switch (unitsToUse)
    {
        case Units.Metric:
            return mostRecentMeasure;
        case Units.Imperial:
            return (decimal)(mostRecentMeasure * 25.4);
        default:
            throw new NotImplementedException();
    }
}
//...
</code></pre>
<p>Найдём метод <code>ImperialValue</code>, а затем удалим тело метода по умолчанию. Добавим код для проверки <code>unitsToUse</code> и, если они эмпирические, вернём значение из поля mostRecentMeasure. Если текущие единицы измерения являются метрическими, вернём результат умножения поля <code>mostRecentMeasure</code> на 0,03937.</p>
<p>Возможная реализация метода <code>ImperialValue</code>:</p>
<pre><code class="language-C#">//...
public decimal ImperialValue()
{
    switch (unitsToUse)
    {
        case Units.Metric:
            return (decimal)(mostRecentMeasure * 0.03937);
        case Units.Imperial:
            return mostRecentMeasure;
        default:
            throw new NotImplementedException();
    }
}
//...
</code></pre>
<p>Добавим в класс конструктор, который принимает параметр типа <code>Units</code> и задает для поля <code>unitToUse</code> значение, заданное этим параметром. Чтобы добавить конструктор можно нажать по названию класса и нажать
<strong>(CTRL + '.')</strong>, после чего выбрать <strong>Создать конструктор</strong>. Ставим галочку только на <strong>unitsToUse</strong>.</p>
<p>Конструктор, который для нас любезно собрал VS studio:</p>
<pre><code class="language-C#">//...
public MeasureLengthDevice(Units unitsToUse)
{
    this.unitsToUse = unitsToUse;
}
//...
</code></pre>
<p>Также, VS studio жалуется на <code>null</code> в <code>dataCaptured</code>, поэтому это следует исправить:</p>
<pre><code class="language-C#">//...
public MeasureLengthDevice(Units unitsToUse)
{
    this.unitsToUse = unitsToUse;
    this.dataCaptured = new int[0];
}
//...
</code></pre>
<p>Дальше стоит запустить проект. Проект должен быть успешно собран.</p>
<h2 id="Часть-14"><a class="header" href="#Часть-14">Часть 1.4</a></h2>
<p>Итак, самое сложное позади, остался лишь интерфейс.</p>
<h3 id="Примерные-требования-к-интерфейсу"><a class="header" href="#Примерные-требования-к-интерфейсу">Примерные требования к интерфейсу:</a></h3>
<p>Listbox или что-то такое чтобы отображать данные.</p>
<p>Кнопка &quot;Получить необработанные данные&quot;: выводит полученные данные на экран.</p>
<p>Кнопка создания устройства: Нужно создать экземпляр <code>MeasureLengthDevice</code> и записать в поле <code>device</code>.
При его создании необходимо использовать выбранную систему измерения.</p>
<p>Кнопка начала сбора: Нужно запустить метод StartCollecting на нашем измерительном устройстве.</p>
<p>Кнопка окончания сбора: Нужно как-то завершить сбор данных.</p>
<p>Кнопка &quot;Метрическое значение&quot;: выводит последнее измерение устройства в метрической системе.</p>
<p>Кнопка &quot;Эмпирическое значение&quot;: выводит последнее измерение устройства в эмпирической системе.</p>
<p>Пример интерфейса:</p>
<p><img src="practices/pr5/./images/pr5-app-interface.png" alt="Интерфейс приложения" /></p>
<p>Если вы всё сделали правильно, то после запуска устройства оно начнёт делать замеры.
После нажатия на кнопку &quot;Получить необработанные данные&quot; будет отображаться содержимое
циклического буфера. По началу там будут только нули, но со временем буфер станет заполнятся
значениями. Оставшиеся кнопки должны по большей части просто вызывать методы нашего класса.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Задание-2-Создание-абстрактного-класса"><a class="header" href="#Задание-2-Создание-абстрактного-класса">Задание 2. Создание абстрактного класса</a></h1>
<p>В этом задании мы определим класс <code>MeasureMassDevice</code>, который также реализует интерфейс <code>IMeasuringDevice</code>. Хотя методы <code>MetricValue</code> и <code>ImperialValue</code> будут реализованы несколько иначе, чем класс <code>MeasureLength</code>, методы <code>StartCollecting</code>, <code>StopCollecting</code>, <code>GetRawData</code> и <code>GetMeasurements</code> будут идентичны. Дублирование кода это плохо и может привести к трудностям в обслуживании. Следовательно, мы создадим абстрактный класс с именем <code>MeasureDataDevice</code>, который предоставляет реализации дублированных методов по умолчанию. Придётся изменить классы <code>MeasureLengthDevice</code> и <code>MeasureMassDevice</code>, чтобы они наследовались от этого класса.</p>
<p>Для начала создадим новый проект с графическим интерфейсом, например, так выглядит создание проекта с Windows Forms:</p>
<p><img src="practices/pr5/../../global/images/win-forms-app-creation.png" alt="Скриншот создания проекта" /></p>
<p>Теперь, исходя из задания, нам нужно реализовать интерфейс из предедущего задания.
Таким образом, можем его спокойно перекопировать. Создадим новый файл через <strong>(Ctrl + Shift + A)</strong></p>
<h3 id="imeasuringdevice-1"><a class="header" href="#imeasuringdevice-1">IMeasuringDevice</a></h3>
<pre><code class="language-C#">namespace MeasuringDevice
{
    public interface IMeasuringDevice
    {
        /// &lt;summary&gt;
        /// Преобразует необработанные данные, собранные устройством измерения, в значение в метрических единицах.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Последнее измерение устройства преобразовано в метрические единицы.&lt;/returns&gt;
        decimal MetricValue();

        /// &lt;summary&gt;
        /// Преобразует необработанные данные, собранные устройством измерения, в значение в имперических единицах.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Последнее измерение устройства преобразовано в имперические единицы.&lt;/returns&gt;
        decimal ImperialValue();

        /// &lt;summary&gt;
        /// Запускает сбор данных устройства измерения.
        /// &lt;/summary&gt;
        void StartCollecting();

        /// &lt;summary&gt;
        /// Останавливает сбор данных устройства измерения.
        /// &lt;/summary&gt;
        void StopCollecting();

        /// &lt;summary&gt;
        /// Предоставляет доступ к необработанным данным, собранным устройством измерения, в любых единицах, используемых устройством.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Необработанные данные, собранные устройством измерения, в их сыром формате.&lt;/returns&gt;
        int[] GetRawData();
    }
}
</code></pre>
<p>Также нам понадобится <code>DeviceType</code> из предедущего задания. Его реализовывали самостоятельно, вот его реализация:</p>
<h3 id="devicetype-1"><a class="header" href="#devicetype-1">DeviceType</a></h3>
<pre><code class="language-C#">namespace DeviceTypeNS
{
    public enum DeviceType
    {
        LENGTH,
        MASS
    }
}
</code></pre>
<p>И ещё нам понадобится ранее самостоятельно реализованный <code>DeviceController</code>:</p>
<h3 id="devicecontroller"><a class="header" href="#devicecontroller">DeviceController</a></h3>
<pre><code class="language-C#">using DeviceTypeNS;

namespace DeviceControllerNS
{
    public class DeviceController
    {
        DeviceType measurementType;
        bool isStopped;

        public DeviceController(DeviceType measurementType)
        {
            this.measurementType = measurementType;
            this.isStopped = false;
        }

        public static DeviceController StartDevice(DeviceType measurementType)
        {
            return new DeviceController(measurementType);
        }

        public void StopDevice()
        {
            this.isStopped = true;
        }

        public int TakeMeasurement()
        {
            if (!this.isStopped)
            {
                Random random = new Random();
                return random.Next(1, 10);
            }
            throw new Exception(&quot;Устройство остановлено, однако, была попытка сделать измерение&quot;);
        }
    }
}
</code></pre>
<p>Теперь абстрактный класс, от которого мы будем наследовать, также можно спокойно скопировать в отдельный файл.</p>
<pre><code class="language-C#">using DeviceTypeNS;
using DeviceControllerNS;

namespace MeasuringDevice
{
    public abstract class MeasureDataDevice : IMeasuringDevice
    {
        /// &lt;summary&gt;
        /// Преобразует необработанные данные, собранные устройством измерения, в значение в метрических единицах.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Последнее измерение устройства преобразовано в метрические единицы.&lt;/returns&gt;
        public abstract decimal MetricValue();
        /// &lt;summary&gt;
        /// Преобразует необработанные данные, собранные устройством измерения, в значение в имперических единицах.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Последнее измерение устройства преобразовано в имперические единицы.&lt;/returns&gt;
        public abstract decimal ImperialValue();
        /// &lt;summary&gt;
        /// Запускает сбор данных устройства измерения.
        /// &lt;/summary&gt;
        public void StartCollecting()
        {
            controller = DeviceController.StartDevice(measurementType);
            GetMeasurements();
        }
        /// &lt;summary&gt;
        /// Останавливает сбор данных устройства измерения.
        /// &lt;/summary&gt;
        public void StopCollecting()
        {
            if (controller != null)
            {
                controller.StopDevice();
                controller = null;
            }
        } 
    }
}
</code></pre>
<p>Заметим, что многое сейчас подчёркнуто красной волнистой полоской.</p>
<p>Нажмём на название нашего класса <code>MeasureDataDevice</code>,
после чего прожмём сочетание <strong>(CTRL + '.')</strong>. Выберем <strong>Реализовать интерфейс абстрактно</strong></p>
<p>Как видим, нужные методы интерфейса теперь автоматически реализованы абстрактно. Однако,
такие методы, как <code>GetRawData</code> и <code>GetMeasurements</code> придётся реализовать по умолчанию. А ещё множество полей всё ещё подчёркнуты красным, поэтому их также надо реализовать.
Всё это также можно взять из предедущего задания:</p>
<p>Поля сделаем публичными, так как это соответствует задаче абстрактного класса.</p>
<pre><code class="language-C#">public int[] dataCaptured;
public int mostRecentMeasure;
public DeviceController? controller;
public DeviceType measurementType;
</code></pre>
<p>Добавим метод <code>GetMeasurements</code>, который ранее просто скопировали, пора это снова повторить.</p>
<h3 id="getmeasurements-1"><a class="header" href="#getmeasurements-1">GetMeasurements</a></h3>
<pre><code class="language-C#">public void GetMeasurements()
{
    dataCaptured = new int[10];
    System.Threading.ThreadPool.QueueUserWorkItem((dummy) =&gt;
    {
        int x = 0;
        Random timer = new Random();

        while (controller != null)
        {
            System.Threading.Thread.Sleep(timer.Next(1000, 5000));
            dataCaptured[x] = controller != null ?
                controller.TakeMeasurement() : dataCaptured[x];
            mostRecentMeasure = dataCaptured[x];
            x++;
            if (x == 10)
            {
                x = 0;
            }
        }
    });
}
</code></pre>
<h3 id="measuredatadevice"><a class="header" href="#measuredatadevice">MeasureDataDevice</a></h3>
<pre><code class="language-C#">using DeviceTypeNS;
using DeviceControllerNS;

namespace MeasuringDevice
{
    public abstract class MeasureDataDevice : IMeasuringDevice
    {
        public int[] dataCaptured;
        public int mostRecentMeasure;
        public DeviceController? controller;
        public DeviceType measurementType;
        /// &lt;summary&gt;
        /// Преобразует необработанные данные, собранные устройством измерения, в значение в метрических единицах.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Последнее измерение устройства преобразовано в метрические единицы.&lt;/returns&gt;
        public abstract decimal MetricValue();
        /// &lt;summary&gt;
        /// Преобразует необработанные данные, собранные устройством измерения, в значение в имперических единицах.
        /// &lt;/summary&gt;
        /// &lt;returns&gt;Последнее измерение устройства преобразовано в имперические единицы.&lt;/returns&gt;
        public abstract decimal ImperialValue();
        /// &lt;summary&gt;
        /// Запускает сбор данных устройства измерения.
        /// &lt;/summary&gt;
        public void StartCollecting()
        {
            controller = DeviceController.StartDevice(measurementType);
            GetMeasurements();
        }
        /// &lt;summary&gt;
        /// Останавливает сбор данных устройства измерения.
        /// &lt;/summary&gt;
        public void StopCollecting()
        {
            if (controller != null)
            {
                controller.StopDevice();
                controller = null;
            }
        }

        public void GetMeasurements()
        {
            dataCaptured = new int[10];
            System.Threading.ThreadPool.QueueUserWorkItem((dummy) =&gt;
            {
                int x = 0;
                Random timer = new Random();

                while (controller != null)
                {
                    System.Threading.Thread.Sleep(timer.Next(1000, 5000));
                    dataCaptured[x] = controller != null ?
                        controller.TakeMeasurement() : dataCaptured[x];
                    mostRecentMeasure = dataCaptured[x];
                    x++;
                    if (x == 10)
                    {
                        x = 0;
                    }
                }
            });
        }


        public int[] GetRawData()
        {
            return dataCaptured;
        }
    }
}
</code></pre>
<p>Теперь нам нужно создать класс <code>MeasureMassDevice</code>. Жмём <strong>(CTRL + SHIFT + A)</strong>
Новый класс также нужно сделать публичным. Пока оставим его пустым.</p>
<p>Также скопируем самостоятельно реализованный класс <code>MeasureLengthDevice</code> в отдельный файл.</p>
<pre><code class="language-C#">public class MeasureLengthDevice : IMeasuringDevice
    {
        private Units unitsToUse;
        private int[] dataCaptured;
        private int mostRecentMeasure;
        private DeviceController? controller;
        private const DeviceType measurementType = DeviceType.LENGTH;

        public MeasureLengthDevice(Units unitsToUse)
        {
            this.unitsToUse = unitsToUse;
            this.dataCaptured = new int[0];
        }

        public int[] GetRawData()
        {
            return dataCaptured;
        }

        public decimal ImperialValue()
        {
            switch (unitsToUse)
            {
                case Units.Metric:
                    return (decimal)(mostRecentMeasure * 0.03937);
                case Units.Imperial:
                    return mostRecentMeasure;
                default:
                    throw new NotImplementedException();
            }
        }

        public decimal MetricValue()
        {
            switch (unitsToUse)
            {
                case Units.Metric:
                    return mostRecentMeasure;
                case Units.Imperial:
                    return (decimal)(mostRecentMeasure * 25.4);
                default:
                    throw new NotImplementedException();
            }
        }

        public void StartCollecting()
        {
            controller = DeviceController.StartDevice(measurementType);
            GetMeasurements();
        }

        public void StopCollecting()
        {
            if (controller != null)
            {
                controller.StopDevice();
                controller = null;
            }
        }

        private void GetMeasurements()
        {
            dataCaptured = new int[10];
            System.Threading.ThreadPool.QueueUserWorkItem((dummy) =&gt;
            {
                int x = 0;
                Random timer = new Random();

                while (controller != null)
                {
                    System.Threading.Thread.Sleep(timer.Next(1000, 5000));
                    dataCaptured[x] = controller != null ?
                        controller.TakeMeasurement() : dataCaptured[x];
                    mostRecentMeasure = dataCaptured[x];
                    x++;
                    if (x == 10)
                    {
                        x = 0;
                    }
                }
            });
        }
    }
</code></pre>
<p>Заметим, что <code>Units</code> у нас нет, поэтому самостоятельно реализованный <code>Units</code> также нужно скопировать в отдельный файл:</p>
<h3 id="units-1"><a class="header" href="#units-1">Units</a></h3>
<pre><code class="language-C#">namespace UnitsEnumeration
{
    /// &lt;summary&gt;
    /// Перечисление, которое используется для указания системы измерения.
    /// &lt;/summary&gt;
    public enum Units
    {
        Metric,
        Imperial
    }
}
</code></pre>
<p>Добавим <code>using UnitsEnumeration</code> в файл нашего класса <code>MeasureLengthDevice</code>.
Примерно так теперь должны выглядить наши <code>using</code>:</p>
<pre><code class="language-C#">using DeviceControllerNS;
using DeviceTypeNS;
using MeasuringDevice;
using UnitsEnumeration;
//...
</code></pre>
<p>Теперь заменим реализацию интерфейса на наследование от нашего нового абстрактного класса
<a href="practices/pr5/task2.html#measuredatadevice">MeasureDataDevice</a>:</p>
<pre><code class="language-C#">//...
public class MeasureLengthDevice : MeasureDataDevice
//...
</code></pre>
<p>Теперь вспомним как выглядит наш абстрактный класс:</p>
<ul>
<li>Все поля публичные, реализованы такие поля, как <code>dataCaptured</code>, <code>mostRecentMeasure</code>, <code>controller</code>, <code>measurementType</code></li>
<li>Методы <code>MetricValue</code> и <code>ImperialValue</code> абстрактные, их наследникам нужно реализовывать самим.</li>
<li>Методы <code>StartCollecting</code>, <code>StopCollecting</code>, <code>GetMeasurements</code>, <code>GetRawData</code> имеют реализацию по умолчанию, их реализовывать необязательно, а в нашем случае их реализовывать не нужно.</li>
</ul>
<p>Раз мы об этом всём вспомнили, вернёмся к нашему классу <code>MeasureLengthDevice</code>.</p>
<p>Начнём с самого простого, удалим такие поля, как <code>dataCaptured</code>, <code>mostRecentMeasure</code>, <code>controller</code>, <code>measurementType</code>, так как они имеют реализацию по умолчанию.</p>
<p>По той же причине удалим методы <code>StartCollecting</code>, <code>StopCollecting</code>, <code>GetMeasurements</code>, <code>GetRawData</code>.</p>
<p>Теперь добавим к методам <code>MetricValue</code> и <code>ImperialValue</code> модификатор <code>override</code>, чтобы перегрузить реализацию абстрактного класса.</p>
<p>Помимо этого подправим поле measurementType.</p>
<p>И всё, класс готов. Вот его возможная реализация:</p>
<h3 id="measurelengthdevice"><a class="header" href="#measurelengthdevice">MeasureLengthDevice</a></h3>
<pre><code class="language-C#">public class MeasureLengthDevice : MeasureDataDevice
{
    private Units unitsToUse;
    new private const DeviceType measurementType = DeviceType.LENGTH;

    public MeasureLengthDevice(Units unitsToUse)
    {
        this.unitsToUse = unitsToUse;
        this.dataCaptured = new int[0];
    }

    override public decimal ImperialValue()
    {
        switch (unitsToUse)
        {
            case Units.Metric:
                return (decimal)(mostRecentMeasure * 0.03937);
            case Units.Imperial:
                return mostRecentMeasure;
            default:
                throw new NotImplementedException();
        }
    }

    override public decimal MetricValue()
    {
        switch (unitsToUse)
        {
            case Units.Metric:
                return mostRecentMeasure;
            case Units.Imperial:
                return (decimal)(mostRecentMeasure * 25.4);
            default:
                throw new NotImplementedException();
        }
    }
}
</code></pre>
<p>Теперь вернёмся к классу <code>MeasureMassDevice</code>. Его нужно реализовать самостоятельно, но, благодаря использованию абстрактного класса не весь. Делаем что-то наподобие <a href="practices/pr5/task2.html#measurelengthdevice">MeasureLengthDevice</a>. Для начала, добавим наследование от абстрактного класса:</p>
<pre><code class="language-C#">using MeasuringDevice;

namespace MeasureMassDeviceNS
{
    public class MeasureMassDevice: MeasureDataDevice
    {
    }
}
</code></pre>
<p>Нажимаем на название нашего класса и жмём <strong>(Ctrl + '.')</strong>, а затем выбираем <strong>реализовать абстрактный класс</strong>. Должны были появиться заглушки для методов <code>ImperialValue</code> и <code>MetricValue</code>.</p>
<p>Дальнейшая реализация зависит лишь от вашей фантазии. <br/>
В том числе и интерфейса... <br/>
Копировать неоткуда...</p>
<h2 id="Бонус-реализация-класса-measuremassdevice"><a class="header" href="#Бонус-реализация-класса-measuremassdevice">Бонус: реализация класса <code>MeasureMassDevice</code></a></h2>
<p>Для начала вспомним, как выглядела реализация <a href="practices/pr5/task2.html#measurelengthdevice">MeasureLengthDevice</a>, а точнее её &quot;нестандартная часть&quot;.</p>
<p>Сначала реализуем поля <code>unitsToUse</code>, <code>measurementType</code>.</p>
<pre><code class="language-C#">//...
private Units unitsToUse;
new private const DeviceType measurementType = DeviceType.MASS;
//...
</code></pre>
<p>Реализуем конструктор для класса <code>MeasureMassDevice</code>:</p>
<pre><code class="language-C#">//...
public MeasureMassDevice(Units unitsToUse)
{
    this.unitsToUse = unitsToUse;
    this.dataCaptured = new int[0];
}
//...
</code></pre>
<p>И пока просто скопируем методы <code>ImperialValue</code> и <code>MetricValue</code> из класса <a href="practices/pr5/task2.html#measurelengthdevice">MeasureLengthDevice</a>:</p>
<pre><code class="language-C#">override public decimal ImperialValue()
{
    switch (unitsToUse)
    {
        case Units.Metric:
            return (decimal)(mostRecentMeasure * 0.03937);
        case Units.Imperial:
            return mostRecentMeasure;
        default:
            throw new NotImplementedException();
    }
}

override public decimal MetricValue()
{
    switch (unitsToUse)
    {
        case Units.Metric:
            return mostRecentMeasure;
        case Units.Imperial:
            return (decimal)(mostRecentMeasure * 25.4);
        default:
            throw new NotImplementedException();
    }
}
</code></pre>
<p>Вспомним, что такое метрическая система...</p>
<blockquote>
<p>Метрическая система или Международная система единиц (СИ) основана на семи базовых единицах для семи    базовых измерений, независимых друг от друга. Вот эти измерения и единицы: длина (метр), масса    (килограмм), время (секунда), электрический ток (ампер), термодинамическая температура (кельвин),    количество вещества (моль) и интенсивность излучения (кандела).</p>
</blockquote>
<p>Вспомним, в чём в имперской системе измеряется масса, достатоно вспомнить только фунт...</p>
<blockquote>
<p>1 фунт = 12 унциям</p>
</blockquote>
<p>Теперь подумаем, в чём будет измеряться масса в нашем классе <code>MeasureMassDevice</code>. Пожалуй, это будут килограммы в (СИ) и футы в имперской системе.</p>
<p>Тогда в методе <code>ImperialValue</code> в первом кейсе надо как-то перевести килограммы в футы. Для этого узнаём, что в одном футе 0.4535924 кг, а в одном кг 2.2046226 футов.</p>
<p>Наконец, без проблем перепишем наш метод <code>ImperialValue</code>:</p>
<pre><code class="language-C#">override public decimal ImperialValue()
{
    switch (unitsToUse)
    {
        case Units.Metric:
            return (decimal)(mostRecentMeasure * 2.2046226);
        case Units.Imperial:
            return mostRecentMeasure;
        default:
            throw new NotImplementedException();
    }
}
</code></pre>
<p>А также метод <code>MetricValue</code>:</p>
<pre><code class="language-C#">override public decimal MetricValue()
{
    switch (unitsToUse)
    {
        case Units.Metric:
            return mostRecentMeasure;
        case Units.Imperial:
            return (decimal)(mostRecentMeasure * 0.4535924);
        default:
            throw new NotImplementedException();
    }
}
</code></pre>
<p>Класс готов, вот его реализация:</p>
<h2 id="measuremassdevice"><a class="header" href="#measuremassdevice">MeasureMassDevice</a></h2>
<pre><code class="language-C#">using DeviceTypeNS;
using MeasuringDevice;
using UnitsEnumeration;

namespace MeasureMassDeviceNS
{
    public class MeasureMassDevice : MeasureDataDevice
    {
        private Units unitsToUse;
        new private const DeviceType measurementType = DeviceType.MASS;

        public MeasureMassDevice(Units unitsToUse)
        {
            this.unitsToUse = unitsToUse;
            this.dataCaptured = new int[0];
        }
        override public decimal ImperialValue()
        {
            switch (unitsToUse)
            {
                case Units.Metric:
                    return (decimal)(mostRecentMeasure * 2.2046226);
                case Units.Imperial:
                    return mostRecentMeasure;
                default:
                    throw new NotImplementedException();
            }
        }

        override public decimal MetricValue()
        {
            switch (unitsToUse)
            {
                case Units.Metric:
                    return mostRecentMeasure;
                case Units.Imperial:
                    return (decimal)(mostRecentMeasure * 0.4535924);
                default:
                    throw new NotImplementedException();
            }
        }
    }
}
// Meow
</code></pre>
<h2 id="Бонус-Интерфейс-приложения"><a class="header" href="#Бонус-Интерфейс-приложения">Бонус: Интерфейс приложения:</a></h2>
<p><strong>Всех этих элементов две штуки:</strong></p>
<ul>
<li>
<p>Listbox или что-то такое чтобы отображать данные.</p>
</li>
<li>
<p>Кнопка &quot;Получить необработанные данные&quot;: выводит полученные данные на экран.</p>
</li>
<li>
<p>Кнопка создания устройства: Нужно создать экземпляр <code>MeasureLengthDevice</code> и записать в поле <code>device</code>.</p>
</li>
<li>
<p>При его создании необходимо использовать выбранную систему измерения.</p>
</li>
<li>
<p>Кнопка начала сбора: Нужно запустить метод StartCollecting на нашем измерительном устройстве.</p>
</li>
<li>
<p>Кнопка окончания сбора: Нужно как-то завершить сбор данных.</p>
</li>
<li>
<p>Кнопка &quot;Метрическое значение&quot;: выводит последнее измерение устройства в метрической системе.</p>
</li>
<li>
<p>Кнопка &quot;Эмпирическое значение&quot;: выводит последнее измерение устройства в эмпирической системе.</p>
</li>
</ul>
<p>Пример интерфейса для <a href="practices/pr5/task2.html#measurelengthdevice">MeasureLengthDevice</a>:</p>
<p><img src="practices/pr5/./images/pr5-app-interface.png" alt="Интерфейс приложения" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Задание-3-Создание-архитектуры-приложения-с-помощью-интерфейсов"><a class="header" href="#Задание-3-Создание-архитектуры-приложения-с-помощью-интерфейсов">Задание 3. Создание архитектуры приложения с помощью интерфейсов</a></h1>
<p>Последовательность выполнения задания следующая:</p>
<ol>
<li>Изучить возможность и преимущества создания архитектуры приложения с помощью интерфейсов.</li>
<li>Написать в отчет о работе краткую справку об использовании абстрактных классов и интерфейсов при проектировании крупных промышленных приложений. Советуем посмотреть видеоурок https://www.youtube.com/watch?v=eXapyrhtj7I&amp;t=111s</li>
<li>Создать архитектуру собственного приложения с помощью интерфейсов.
Обеспечить частичную или полную реализацию классов.
В качестве примера можно выбрать: книжный магазин, расширенный блокнот для делопроизводства, интернет магазин для продажи компьютеров и т.п.</li>
<li>Разработать и включить в отчет диаграмму UML для вашего приложения.</li>
</ol>
<h2 id="Часть-1"><a class="header" href="#Часть-1">Часть 1</a></h2>
<p>Интерфейсы - это основной кирпичик, позволяющий использовать композицию вместо наследования. Ознакомимся с тем, что же такое эта &quot;композиция&quot;</p>
<h3 id="Композиция-вместо-наследования"><a class="header" href="#Композиция-вместо-наследования">Композиция вместо наследования</a></h3>
<h4 id="Википедия"><a class="header" href="#Википедия"><a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">Википедия:</a></a></h4>
<p>Предпочтение композиции перед наследованием - это принцип проектирования, который придает дизайну большую гибкость. Более естественно создавать классы бизнес-домена из различных компонентов, чем пытаться найти общность между ними и создавать генеалогическое древо. Например, педаль акселератора и рулевое колесо имеют очень мало общих черт, но оба являются жизненно важными компонентами автомобиля. Что они могут делать и как их можно использовать с пользой для автомобиля, легко определить. Композиция также обеспечивает более стабильную бизнес-сферу в долгосрочной перспективе, поскольку она менее подвержена причудам членов семьи. Другими словами, лучше составить то, что объект может делать (имеет-a), чем расширять то, что он есть (is-a).</p>
<p>Первоначальное проектирование упрощается за счет определения поведения системных объектов в отдельных интерфейсах вместо создания иерархической взаимосвязи для распределения поведения между классами бизнес-домена посредством наследования. Этот подход легче приспосабливается к будущим изменениям требований, которые в противном случае потребовали бы полной реструктуризации классов бизнес-домена в модели наследования. Кроме того, это позволяет избежать проблем, часто связанных с относительно незначительными изменениями в модели, основанной на наследовании, которая включает несколько поколений классов. Композиционное отношение более гибкое, поскольку его можно изменять во время выполнения, в то время как отношения подтипов статичны и требуют перекомпиляции на многих языках.</p>
<p>Некоторые языки, в частности <strong>Go</strong> и <strong>Rust</strong>, используют исключительно <strong>type composition</strong>.</p>
<h4 id="Шаблоны-игрового-программирования-Роберт-Найстром"><a class="header" href="#Шаблоны-игрового-программирования-Роберт-Найстром">Шаблоны игрового программирования. Роберт Найстром</a></h4>
<blockquote>
<p>Дальнейший материал данного пункта полностью взят из перевода указанной <a href="https://martalex.gitbooks.io/gameprogrammingpatterns/content/chapter-5/5.1-component.html">книги</a>.</p>
</blockquote>
<p>Когда объектно-ориентированное программирование появилось на сцене
впервые, наследование было самым любимым из всех его инструментов. Оно
было объявлено ультимативным молотом повторного использования кода и
кодеры постоянно им размахивали. С тех пор мы на собственных ошибках
убедились в том, что этот молот может быть слишком тяжел. Наследование имеет
свое применение, но для повторного использования кода оно обычно слишком
громоздко.</p>
<p>Ему на замену в программирование пришел новый тренд: композиция взамен
наследования везде, где это возможно. Вместо совместного использования кода двумя
классами, которые наследуются от какого-то одного класса, мы позволяем им обеим
обладать одним и тем же экземпляром этого класса.</p>
<h2 id="Часть-2"><a class="header" href="#Часть-2">Часть 2.</a></h2>
<p>Возможную версию справки об использовании абстрактных классов и интерфейсов при проектировании крупных промышленных приложений можно посмотреть <a href="practices/pr5/../../appendix/intefaces_and_abstract_classes_in_app_design.html">тут</a>.</p>
<h2 id="Часть-3"><a class="header" href="#Часть-3">Часть 3.</a></h2>
<p>Для начала определимся с идеей. Тут у нас в приоритете создание чего-то такого промышленного.
Возможные идеи:</p>
<ul>
<li>книжный магазин.</li>
<li>расширенный блокнот для делопроизводства.</li>
<li>интернет магазин для продажи компьютеров.</li>
<li>http веб фреймворк.</li>
<li>веб-сервис по генерации изображений искусственным интеллектом.</li>
<li>веб-сервис по разработке дизайна приложения.</li>
<li>канбан доска.</li>
</ul>
<p>Тут мы ограничены лишь своей фантазией.
Заметим, что сказано частично или полностью реализовать классы, что будет проблемой при создании абсолютно воображаемого приложения. </p>
<h3 id="Возможная-реализация-архитектуры-приложения-с-помощью-интерфейсов"><a class="header" href="#Возможная-реализация-архитектуры-приложения-с-помощью-интерфейсов">Возможная реализация архитектуры приложения с помощью интерфейсов</a></h3>
<p>Ну что же, проект делать всеравно другой в итоге, сделаем книжный магазин!
В интерфейсы пожалуй будем добавлять только методы.</p>
<p>Итак, какие сущности обитают в книжном магазине? Книги?
В общем так, рассмотрим воображаемый сайт книжного магазина. Там обязательно есть кнопочка купить, 
есть страничка книги, есть поиск книг... На этом пожалуй хватит.</p>
<p>Пускай будет интерфейс <code>IBook</code>, хотя, тогда в нём будут лишь поля, да и громоздний наверное выйдет интерфейс...</p>
<p>Тогда сделаем интерфейсы <code>IHasDescription</code>, <code>IHasAuthor</code>, <code>IHasGenre</code>, <code>IHasReleaseDate</code>, <code>IHasName</code>, <code>IPage</code>, <code>IHasPages</code>.</p>
<p>Также, пускай будет интерфейс <code>IForSale</code>, 
Из <code>IHasDescription</code>, <code>IHasAuthor</code>, <code>IHasGenre</code>, <code>IHasReleaseDate</code>, <code>IHasName</code>, <code>IHasPages</code>, <code>IForSale</code>. соберём класс книги, а потом попробуем собрать что-нибудь ещё.</p>
<p>Пускай будет интерфейс <code>ISearch</code>, который будет реализовывать возможность гибкого поиска по какой-либо коллекции, пускай будет абстрактный класс <code>Library</code> который будет использовать <code>ISearch</code>.</p>
<p>Также добавим абстрактный класс магазина <code>Shop</code>, где используем интерфейсы <code>IHasAuthor</code>, <code>IHasName</code>, <code>IHasDescription</code>, <code>IHasReleaseDate</code></p>
<p>Как-то так. План следующий:</p>
<ul>
<li>Реализуем интерфейсы.</li>
<li>Собираем абстрактные классы.</li>
<li>Отдыхаем.</li>
</ul>
<h3 id="Список-всех-интерфейсов-для-реализации"><a class="header" href="#Список-всех-интерфейсов-для-реализации">Список всех интерфейсов для реализации:</a></h3>
<ul>
<li><a href="practices/pr5/task3.html#ihasdescription">IHasDescription</a> - Интерфейс для всего, что имеет описание.</li>
<li><a href="practices/pr5/task3.html#ihasauthor">IHasAuthor</a> - Интерфейс для всего, у чего есть автор.</li>
<li><a href="practices/pr5/task3.html#ihasgenre">IHasGenre</a> - Интерфейс для всего, у чего есть жанр.</li>
<li><a href="practices/pr5/task3.html#ihasreleasedate">IHasReleaseDate</a> - Интерфейс для всего, у чего есть дата выпуска.</li>
<li><a href="practices/pr5/task3.html#ihasname">IHasName</a> - Интерфейс для всего, у чего есть имя или название.</li>
<li><a href="practices/pr5/task3.html#ihaspages">IHasPages</a> - Интерфейс для всего, у чего есть страницы.</li>
<li><a href="practices/pr5/task3.html#iforsale">IForSale</a> - Интерфейс для всего, что можно продать.</li>
<li><a href="practices/pr5/task3.html#isearch">ISearch</a> - Интерфейс для всего, что может реализовывать поиск.</li>
</ul>
<h3 id="Список-всех-абстрактных-классов-для-реализации"><a class="header" href="#Список-всех-абстрактных-классов-для-реализации">Список всех абстрактных классов для реализации:</a></h3>
<ul>
<li><a href="practices/pr5/task3.html#page">Page</a> - реализует <code>IHasReleaseDate</code>, <code>IHasName</code>, <code>IHasDescription</code>.</li>
<li><a href="practices/pr5/task3.html#book">Book</a> - реализует все наши интерфейсы, кроме <code>ISearch</code>.</li>
<li><a href="practices/pr5/task3.html#library">Library</a> - реализует <code>ISearch</code>.</li>
<li><a href="practices/pr5/task3.html#shop">Shop</a> - реализует <code>IHasAuthor</code>, <code>IHasName</code>, <code>IHasDescription</code>, <code>IHasReleaseDate</code>.</li>
</ul>
<p>Начнём с того, что создадим заглушки под каждый интерфейс.
Жмём <strong>(Ctrl+Shift+A)</strong>, выбираем интерфейс и называем его <code>IHasDescription</code>, создаём.</p>
<p>Теперь проделаем это со всеми остальными, тоесть <code>IHasAuthor</code>, <code>IHasGenre</code>, <code>IHasReleaseDate</code>, <code>IHasName</code>, <code>IHasPages</code>, <code>IForSale</code>, <code>ISearch</code>.</p>
<p>Перед тем, как реализовывать <code>IHasPages</code>, придётся реализовать абстрактный класс <code>Page</code>, который будет реализовывать интерфейсы <code>IHasReleaseDate</code>, <code>IHasName</code>, <code>IHasDescription</code></p>
<p>Хочется отметить, что в ходе выполнения работы список интерфейсов постоянно менялся, а они самым неожиданным образом становились частями разных классов, хотя изначально создавались только для Book и Library. Это ещё раз подчёркивает гибкость <a href="practices/pr5/task3.html#%D0%B2%D0%B8%D0%BA%D0%B8%D0%BF%D0%B5%D0%B4%D0%B8%D1%8F">композиции</a>.</p>
<p>А теперь спокойненько всё реализовываем. Вот примерная реализация:</p>
<h3 id="ihasdescription"><a class="header" href="#ihasdescription">IHasDescription</a></h3>
<pre><code class="language-C#">public interface IHasDescription
{
    string Description { get; set; }

    bool HasDescription() { return Description!= null &amp;&amp; Description.Trim().Length &gt; 0; }

    void FormatDescription() { Description = Description.Trim(); }

    void ClearDescription() { Description = &quot;&quot;; }

    void GetDescription() { &quot;Описание: &quot;.Concat(Description); }
}
</code></pre>
<h3 id="ihasauthor"><a class="header" href="#ihasauthor">IHasAuthor</a></h3>
<pre><code class="language-C#">public interface IHasAuthor
{
    string AuthorName { get; }

    uint AuthorAge { get; }

    string AuthorAbout { get; }

    bool ValidateAuthor();
}
</code></pre>
<h3 id="ihasgenre"><a class="header" href="#ihasgenre">IHasGenre</a></h3>
<pre><code class="language-C#">public interface IHasGenre
{
    HashSet&lt;string&gt; Genres { get; }

    bool ContainsGenre(string genre) { return Genres.Contains(genre); }

    string[] GetGenres() { return Genres.ToArray(); }

    void AddGenre(string genre) { Genres.Add(genre); }

    void RemoveGenre(string genre) { Genres.Remove(genre); }

}
</code></pre>
<h3 id="ihasreleasedate"><a class="header" href="#ihasreleasedate">IHasReleaseDate</a></h3>
<pre><code class="language-C#">public interface IHasReleaseDate
{
    DateTime releaseDate { get; set; }

    void ReleaseBook() { releaseDate = DateTime.Now.ToUniversalTime(); }

    void SetReleaseDate(DateTime releaseDate) { releaseDate = releaseDate.ToUniversalTime(); }

    DateTime ReleasedAt() { return releaseDate; }

    bool isOlderReleased(DateTime someDate) { return releaseDate &gt; someDate; }

    bool isNewerReleased(DateTime someDate) { return releaseDate &lt; someDate; }
}
</code></pre>
<h3 id="ihasname"><a class="header" href="#ihasname">IHasName</a></h3>
<pre><code class="language-C#">public interface IHasName
{
    string Name { get; }

    bool IsValidName(string name);

}
</code></pre>
<p>Мы дошли до IHasPages, а значит, пора реализовывать первый абстрактный класс - <code>Page</code>
Он должен реализовывать интерфейсы <code>IHasReleaseDate</code>, <code>IHasName</code>, <code>IHasDescription</code>.</p>
<p>Напишем, что мы их реализуем:</p>
<pre><code class="language-C#">public abstract class Page: IHasReleaseDate, IHasName, IHasDescription
{

}
</code></pre>
<p>А затем нажмём по всем интерфейсам <strong>(Ctrl + '.')</strong> и создадим заглушки, а также создадим таким же образом конструктор, после чего просто пойдём дальше делать каркас нашего приложения.</p>
<p>Версия с заглушками: </p>
<pre><code class="language-C#">public abstract class Page : IHasReleaseDate, IHasName, IHasDescription
{
    public DateTime releaseDate { get =&gt; throw new NotImplementedException(); set =&gt; throw new NotImplementedException(); }

    public string Name =&gt; throw new NotImplementedException();

    public string Description { get =&gt; throw new NotImplementedException(); set =&gt; throw new NotImplementedException(); }

    public bool IsValidName(string name)
    {
        throw new NotImplementedException();
    }
}
</code></pre>
<h3 id="ihaspages"><a class="header" href="#ihaspages">IHasPages</a></h3>
<pre><code class="language-C#">public interface IHasPages
{
    Page[] pages { get; set; }

    int pagesCount() { return pages.Length; }

    void addPage(Page newPage) { pages.Append(newPage); }
    void removePage(int pageNumber) { pages = pages.Where((_, idx) =&gt; idx != pageNumber).ToArray(); }
}
</code></pre>
<h3 id="iforsale"><a class="header" href="#iforsale">IForSale</a></h3>
<pre><code class="language-C#">public interface IForSale
{
    int price { get; set; }

    int discount { get; set; }

    int getPrice() { return Math.Max(price - discount, 0); }
}
</code></pre>
<h3 id="isearch"><a class="header" href="#isearch">ISearch</a></h3>
<pre><code class="language-C#">public interface ISearch &lt;T&gt;
{
    T[] SearchAll();

    T Find(Func&lt;T, bool&gt; predicate);
}
</code></pre>
<p>Теперь, когда мы реализовали все интерфейсы, пока бы начать реализовывать классы.</p>
<h3 id="page"><a class="header" href="#page">Page</a></h3>
<pre><code class="language-C#">public abstract class Page : IHasReleaseDate, IHasName, IHasDescription
{
    protected Page(DateTime releaseDate, string name, string description)
    {
        this.releaseDate = releaseDate;
        this.name = name;
        this.description = description;
    }

    public DateTime releaseDate { get; set; }
    public string name { get; set; }
    public string description { get; set; }

    public string Name =&gt; name;

    public string Description { get =&gt; description; set { description = value; } }

    abstract public bool IsValidName(string name);
}
</code></pre>
<p>Для книги нам необходимо реализовать все наши интерфейсы кроме <code>ISearch</code>:</p>
<pre><code class="language-C#">public abstract class Book: IForSale, IHasAuthor, IHasDescription, IHasGenre, IHasName, IHasPages, IHasReleaseDate
{

}
</code></pre>
<blockquote>
<p>Совет: пользуйтесь <strong>(Ctrl + '.')</strong> для реализации интерфейсов.</p>
</blockquote>
<h3 id="book"><a class="header" href="#book">Book</a></h3>
<pre><code class="language-C#">public abstract class Book : IForSale, IHasAuthor, IHasDescription, IHasGenre, IHasName, IHasPages, IHasReleaseDate
{
    protected Book(string name, int price, int discount, string authorName, uint authorAge, string authorAbout, string description, Page[] pages, DateTime releaseDate)
    {
        this.name = name;
        this.price = price;
        this.discount = discount;
        this.authorName = authorName;
        this.authorAge = authorAge;
        this.authorAbout = authorAbout;
        Description = description;
        this.pages = pages;
        this.releaseDate = releaseDate;
    }

    public string name { get; set; }
    public int price { get; set; }
    public int discount { get; set; }
    public string authorName { get; set; }
    public uint authorAge { get; set; }
    public string authorAbout { get; set; }
    public string AuthorName =&gt; authorName;

    public uint AuthorAge =&gt; authorAge;

    public string AuthorAbout =&gt; authorAbout;

    public string Description { get; set; }
    public abstract HashSet&lt;string&gt; Genres { get; }

    public string Name =&gt; name;

    public Page[] pages { get; set; }
    public DateTime releaseDate { get; set; }

    public abstract bool IsValidName(string name);

    public abstract bool ValidateAuthor();
}
</code></pre>
<p>Library<code>должен реализовывать</code>ISearch`.</p>
<h3 id="library"><a class="header" href="#library">Library</a></h3>
<pre><code class="language-C#">public abstract class Library : ISearch&lt;Book&gt;
{
    public abstract Book Find(Func&lt;Book, bool&gt; predicate);
    public abstract Book[] SearchAll();
}
</code></pre>
<p>Абстрактный класс <code>Shop</code> реализует интерфейсы <code>IHasAuthor</code>, <code>IHasName</code>, <code>IHasDescription</code>, <code>IHasReleaseDate</code></p>
<h3 id="shop"><a class="header" href="#shop">Shop</a></h3>
<pre><code class="language-C#">public abstract class Shop : IHasAuthor, IHasName, IHasDescription, IHasReleaseDate
{
    protected Shop(string authorName, uint authorAge, string authorAbout, string name, string description, DateTime releaseDate)
    {
        AuthorName = authorName;
        AuthorAge = authorAge;
        AuthorAbout = authorAbout;
        Name = name;
        Description = description;
        this.releaseDate = releaseDate;
    }

    public string AuthorName { get; }
    public uint AuthorAge { get; }
    public string AuthorAbout { get; }
    public string Name { get; }
    public string Description { get; set; }
    public DateTime releaseDate { get; set; }

    public abstract bool IsValidName(string name);
    public abstract bool ValidateAuthor();
}
</code></pre>
<h2 id="Часть-4"><a class="header" href="#Часть-4">Часть 4.</a></h2>
<p>Для построения UML диаграмм рекомендуется использовать <a href="https://staruml.io">StarUML</a></p>
<p>Вот такая диаграмма вышла в итоге:
<img src="practices/pr5/./images/diagram-creation-7.png" alt="Конечная диаграмма классов" /></p>
<p>Перейдём к процессу создания такой диаграммы:</p>
<p>После открытия программы у нас уже есть диаграмма <strong>Main</strong>, это и есть диаграмма классов.</p>
<p><img src="practices/pr5/./images/diagram-creation-1.png" alt="Main" /></p>
<p>Далее выберем интерфейс в меню слева:</p>
<p><img src="practices/pr5/./images/diagram-creation-2.png" alt="Выберем интерфейс" /></p>
<p>И начнём добавлять в диаграмму наши интерфейсы:</p>
<p><img src="practices/pr5/./images/diagram-creation-3.png" alt="Добавляем интерфейсы" /></p>
<p>После добавления интерфейсов добавим классы:</p>
<p><img src="practices/pr5/./images/diagram-creation-4.png" alt="Добавляем классы" /></p>
<p>Обозначим их все абстрактными:</p>
<p><img src="practices/pr5/./images/diagram-creation-5.png" alt="Обозначим абстрактными классы" /></p>
<p>Теперь нам надо правильно соединить интерфейсы. Я начну с тех, которые были реализованы сразу во многих классах. Для этого посмотрим на то, <a href="practices/pr5/task3.html#%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA-%D0%B2%D1%81%D0%B5%D1%85-%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D1%8B%D1%85-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2-%D0%B4%D0%BB%D1%8F-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">какие классы что реализуют</a>.</p>
<p>Для отображения реализации интерфейсов используйте тип соединения <strong>Inteface Realization</strong></p>
<p>Заметим, что интерфейсы <code>IHasName</code>, <code>IHasDescription</code>, <code>IHasReleaseDate</code> были реализованы сразу в двух классах. Поэтому их мы соединим первыми:</p>
<p><img src="practices/pr5/./images/diagram-creation-6.png" alt="Соединяем интерфейсы 1" /></p>
<p>Кстати, стоило бы заметить и то, что <code>IHasAuthor</code> также реализован в двух классах, но бывает.</p>
<p>Теперь соединим оставшиеся:</p>
<h3 id="Конечная-диаграмма-классов"><a class="header" href="#Конечная-диаграмма-классов">Конечная диаграмма классов:</a></h3>
<p><img src="practices/pr5/./images/diagram-creation-7.png" alt="Конечная диаграмма классов" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Практическая-работа-6"><a class="header" href="#Практическая-работа-6">Практическая работа №6</a></h1>
<h2 id="Тема-Наследование-классов-и-использование-интерфейсов-1"><a class="header" href="#Тема-Наследование-классов-и-использование-интерфейсов-1">Тема: Наследование классов и использование интерфейсов</a></h2>
<p><strong>Цель работы:</strong> Научиться на практике использованию делегатов, лямбда-выражений и событий. Научиться создавать собственные события.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Ключевые-понятия-1"><a class="header" href="#Ключевые-понятия-1">Ключевые понятия</a></h1>
<ul>
<li><a href="practices/pr6/key_concepts.html#%D0%94%D0%B5%D0%BB%D0%B5%D0%B3%D0%B0%D1%82%D1%8B">Delegate(Делегаты)</a></li>
<li><a href="practices/pr6/key_concepts.html#%D0%9C%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BA%D0%B0%D1%81%D1%82-%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B0%D1%82%D1%8B">MulticastDelegate</a></li>
<li><a href="practices/pr6/key_concepts.html#%D0%A6%D0%B5%D0%BF%D0%BE%D1%87%D0%BA%D0%B8-%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B0%D1%82%D0%BE%D0%B2">Цепочки делегатов “+=”;  “-=”</a></li>
<li><a href="practices/pr6/key_concepts.html#%D0%9B%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B2%D1%8B%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F">Лямбда-выражения “=&gt;”</a></li>
<li><a href="practices/pr6/key_concepts.html#%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8-%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0-callback">Функции обратного вызова (callback)</a></li>
<li><a href="practices/pr6/key_concepts.html#event-%D0%A1%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B5">Event (Событие)</a></li>
<li><a href="practices/pr6/key_concepts.html#eventhandler-%D0%9E%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F">EventHandler (Обработчик события)</a></li>
<li><a href="practices/pr6/key_concepts.html#%D0%9A%D0%BB%D0%B0%D1%81%D1%81-sender-%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B-receivers">класс Sender и классы Receivers</a></li>
<li><a href="practices/pr6/key_concepts.html#%D0%9A%D0%BB%D0%B0%D1%81%D1%81-eventargs-%D0%B8-%D0%B5%D0%B3%D0%BE-%D0%BF%D0%BE%D1%82%D0%BE%D0%BC%D0%BA%D0%B8">класс EventArgs и его потомки</a></li>
<li><a href="practices/pr6/key_concepts.html#%D0%9A%D0%BB%D0%B0%D1%81%D1%81-receiver">Класс Receiver</a></li>
<li><a href="practices/pr6/key_concepts.html#%D0%A1%D0%B2%D1%8F%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0-%D1%81-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B5%D0%BC">Связывание обработчика с событием</a></li>
<li><a href="practices/pr6/key_concepts.html#%D0%9E%D1%82%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0">Отключение обработчика</a></li>
<li><a href="practices/pr6/key_concepts.html#%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D1%81%D0%B2%D1%8F%D0%B7%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B9-%D1%81-%D0%B8%D1%85-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0%D0%BC%D0%B8">Динамическое связывание событий с их обработчиками</a></li>
</ul>
<p>Хотя ключевых понятий указано много, по сути всё, что нужно изучить, это делегаты, события и лямбда выражения.
По сути всё что тут есть относится к делегатам или является ими.</p>
<p>Многие ключевые понятия по сути дублируются, однако, оставляем как в оригинальной методичке.</p>
<h2 id="Делегаты"><a class="header" href="#Делегаты">Делегаты</a></h2>
<p>Делегаты - это указатели на методы и с помощью делегатов мы можем вызвать методы по указателю.</p>
<h3 id="Определение-делегатов"><a class="header" href="#Определение-делегатов">Определение делегатов</a></h3>
<p>Для объявления делегата используется ключевое слово <code>delegate</code>, после которого идет возвращаемый тип, название и параметры. Например:</p>
<pre><code class="language-C#">delegate void Message();
</code></pre>
<p>Делегат <code>Message</code> в качестве возвращаемого типа имеет тип <code>void</code> (то есть ничего не возвращает) и не принимает никаких параметров. Это значит, что этот делегат может указывать на любой метод, который не принимает никаких параметров и ничего не возвращает.</p>
<p>Рассмотрим примение этого делегата:</p>
<pre><code class="language-C#">using System;

public class Program
{
    void Hello() =&gt; Console.WriteLine(&quot;Amogus ඞ&quot;);  // Объявляем метод
    delegate void Message();  // Объявляем делегат

    public static void Main()
    {
        Program p = new Program();  // Создаем экземпляр класса Program
        Message mes = p.Hello;      // Присваиваем переменной mes адрес метода Hello
        mes();                      // Вызываем метод Hello, выведет: Amogus ඞ
    }
}
</code></pre>
<p>Делегаты могут быть переданы как параметры метода, методы могут возвращать делегаты, делегаты
могут запускать несколько методов сразу.</p>
<blockquote>
<p>Более подробно о <a href="practices/pr6/../../appendix/delegate.html">делегатах</a></p>
</blockquote>
<h2 id="Мультикаст-делегаты"><a class="header" href="#Мультикаст-делегаты">Мультикаст-делегаты</a></h2>
<p>Делегаты, которые включают в себя больше одного метода, называют <strong>мультикаст-делегатами</strong>, <a href="practices/pr6/../../appendix/delegate.html#%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%B2-%D0%B2-%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B0%D1%82">подробнее</a>.</p>
<h2 id="Цепочки-делегатов"><a class="header" href="#Цепочки-делегатов">Цепочки делегатов</a></h2>
<p>Так как делегаты могут содержать в себе больше одного метода, мы можем через += и -= <a href="practices/pr6/../../appendix/delegate.html#%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%B2-%D0%B2-%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B0%D1%82">добавлять методы</a> и <a href="practices/pr6/../../appendix/delegate.html#%D0%A3%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%BE%D0%B2-%D0%B8%D0%B7-%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B0%D1%82%D0%B0">удалять методы</a> из списка вызовов делегата. <a href="practices/pr6/">подробнее</a></p>
<h2 id="Лямбда-выражения"><a class="header" href="#Лямбда-выражения">Лямбда-выражения</a></h2>
<p>Лямбда-выражения представляют упрощенную запись анонимных методов. Лямбда-выражения позволяют создать емкие лаконичные методы, которые могут возвращать некоторое значение и которые можно передать в качестве параметров в другие методы.</p>
<p>С точки зрения типа данных лямбда-выражение представляет <a href="practices/pr6/./delegate.html">делегат</a>. Таким образом с лямбдами можно делать всё тоже, что и с делегатами. Определим простейшее лямбда-выражение:</p>
<pre><code class="language-C#">delegate void Message();
Message hello = () =&gt; Console.WriteLine(&quot;Hello&quot;);
hello();  // Hello
</code></pre>
<p>Если лямбда-выражение содержит несколько действий, то они помещаются в фигурные скобки:</p>
<pre><code class="language-C#">Message hello = () =&gt;
{
    Console.Write(&quot;Hello &quot;);
    Console.WriteLine(&quot;World&quot;);
};
hello();  // Hello World
</code></pre>
<blockquote>
<p>Более подробно о <a href="practices/pr6/../../appendix/lambda.html">лямбдах</a></p>
</blockquote>
<h2 id="Функции-обратного-вызова-callback"><a class="header" href="#Функции-обратного-вызова-callback">Функции обратного вызова (callback)</a></h2>
<p>В компьютерном программировании <strong>callback</strong> — это исполняемый код, который передается в качестве аргумента другому коду. Таким образом callback-ом может быть любой делегат (лямбда). Простой пример callback-а в C#:</p>
<pre><code class="language-C#">int[] nums = {1, 2, 3, 4};

// лямбда в качестве параметра метода Where
nums = nums.Where((num) =&gt; num % 2 == 0).ToArray();
foreach (int element in nums)
    Console.Write(element + &quot; &quot;); // 2 4
</code></pre>
<h2 id="event-Событие"><a class="header" href="#event-Событие">Event (Событие)</a></h2>
<p>События — это особый вид делегата, который может вызываться только из класса (или производных классов) или структуры, где они объявлены (класс издателя).</p>
<p>События объявляются в классе с помощью ключевого слова <code>event</code>, после которого указывается тип делегата, который представляет событие:</p>
<pre><code class="language-C#">delegate void AccountHandler(string message);
event AccountHandler Notify;
</code></pre>
<p>У событий также могут быть обработчики, которые срабатывают когда то или иное событие происходит. Обработчики можно добавлять и удалять как обыкновенные делегаты.</p>
<pre><code class="language-C#">void DisplayMessage(string message) =&gt; Console.WriteLine(message);
Notify += DisplayMessage;   // Добавляем обработчик для события Notify
Notify(&quot;Только сегодня и только сейчас, скидки 200% на всё...(много текста)&quot;)
// Наш обработчик перехватит событие и выведет его
</code></pre>
<blockquote>
<p>Более подробно о <a href="practices/pr6/../../appendix/events.html">событиях</a></p>
</blockquote>
<blockquote>
<p>Помимо нативной реализации событий в C#, есть ещё модель событий <a href="practices/pr6/../../appendix/dot_net_events.html">.NET Framework</a>, которую тоже нужно понимать.</p>
</blockquote>
<h2 id="eventhandler-Обработчик-события"><a class="header" href="#eventhandler-Обработчик-события">EventHandler (Обработчик события)</a></h2>
<p>Представляет метод, обрабатывающий событие с данными.</p>
<pre><code class="language-C#">public delegate void EventHandler(object? sender, EventArgs e);
</code></pre>
<ul>
<li><code>sender</code> - Объект-источник события. Например, кнопка Windows Forms или ещё что-то</li>
<li><code>e</code> - <code>EventArgs</code>. Если экземпляр класса EventArgs, то не содержит данных о событии. Если наследник, то может передавать в событии полезную информацию</li>
</ul>
<p>Относится к модели событий <a href="practices/pr6/../../appendix/dot_net_events.html">.NET Framework</a></p>
<h2 id="Класс-sender-и-классы-receivers"><a class="header" href="#Класс-sender-и-классы-receivers">Класс Sender и классы Receivers</a></h2>
<p>Под классом <strong>Sender</strong> подразумевается любой класс, генерирующий события.
Под классами <strong>Receivers</strong> подразумеваются классы, получающие события.</p>
<p>Класс, отправитель сообщения, в принципе, не знает своих получателей. Одно и то же сообщение может быть получено и по-разному обработано произвольным числом объектов разных классов.</p>
<h2 id="Класс-eventargs-и-его-потомки"><a class="header" href="#Класс-eventargs-и-его-потомки">Класс EventArgs и его потомки</a></h2>
<p><code>EventArgs</code> сам по себе не содержит данных о событии. Но наследники данного класса могут передавать полезную информацию о событии. Вот определение класса <code>EventArgs</code></p>
<pre><code class="language-C#">public class EventArgs
{
    public static readonly EventArgs Empty;
}
</code></pre>
<p>Относится к модели событий <a href="practices/pr6/../../appendix/dot_net_events.html">.NET Framework</a></p>
<h2 id="Класс-receiver"><a class="header" href="#Класс-receiver">Класс Receiver</a></h2>
<p>Получатель сообщения (события) может объявлять множественные обработчики события. Например, форма может получать события нажатых кнопок и реагировать на них как угодно. Например, если событие отправляет TextBox, мы можем запретить запись конкретного символа в него.</p>
<h2 id="Связывание-обработчика-с-событием"><a class="header" href="#Связывание-обработчика-с-событием">Связывание обработчика с событием</a></h2>
<p>Производится оператором +=. Обработчиков может быть множество.</p>
<blockquote>
<p><a href="practices/pr6/../../appendix/events.html#%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D1%8F">Подробнее</a></p>
</blockquote>
<h2 id="Отключение-обработчика"><a class="header" href="#Отключение-обработчика">Отключение обработчика</a></h2>
<p>Также, обработчики можно удалять через -=.</p>
<blockquote>
<p><a href="practices/pr6/../../appendix/events.html#%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%BE%D0%B2">Подробнее</a></p>
</blockquote>
<h2 id="Динамическое-связывание-событий-с-их-обработчиками"><a class="header" href="#Динамическое-связывание-событий-с-их-обработчиками">Динамическое связывание событий с их обработчиками</a></h2>
<p>Динамическое связывание событий с их обработчиками в C# осуществляется с помощью метода += или -=. Этот метод используется для добавления или удаления обработчика события из списка обработчиков.</p>
<blockquote>
<p><a href="practices/pr6/../../appendix/events.html#%D0%94%D0%BE%D0%B1%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8-%D1%83%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%BE%D0%B2">Подробнее</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Задание-1-Использование-событий"><a class="header" href="#Задание-1-Использование-событий">Задание 1. Использование событий</a></h1>
<h2 id="Введение-1"><a class="header" href="#Введение-1">Введение</a></h2>
<h1 id="ВНИМАНИЕ-ГЛАВА-НАХОДИТСЯ-В-РАЗРАБОТКЕ"><a class="header" href="#ВНИМАНИЕ-ГЛАВА-НАХОДИТСЯ-В-РАЗРАБОТКЕ"><strong>ВНИМАНИЕ! ГЛАВА НАХОДИТСЯ В РАЗРАБОТКЕ.</strong></a></h1>
<p>В этом упражнении мы изменим интерфейс <code>IMeasuringDevice</code> и добавим событие <code>NewMeasurementTaken</code>. Это событие будет запускаться каждый раз, когда устройство обнаруживает изменение и выполняет новое измерение.</p>
<p>Мы изменим абстрактный класс <code>MeasureDataDevice</code> из предыдущей лабораторной работы и реализуем событие. Событие <code>NewMeasurementTaken</code> произойдет после того, как устройство заполнит внутренний буфер новым измерением и зарегистрирует его.</p>
<p>Мы будем использовать компонент <code>BackgroundWorker</code> для опроса новых измерений. Опрос новых измерений будет происходить в событии <code>DoWork</code>, а событие <code>ProgressReported</code> вызовет событие <code>NewMeasurementTaken</code>, чтобы уведомить клиентское приложение о том, что было выполнено новое измерение.</p>
<p>Мы запустим фоновый поток с помощью метода <code>RunWorkerAsync</code>, а устройство будет поддерживать отмену фонового потока с помощью метода <code>CancelWorkerAsync</code>.</p>
<p>Мы протестируем новую функциональность, используя приложение, которое создает экземпляр класса <code>MeasureMassDevice</code> и перехватывает вызываемые им события с помощью делегата. Приложение должно иметь возможность приостановить, а затем перезапустить класс <code>MeasureMassDevice</code>.</p>
<p><strong>Настоятельно рекомендуется скопировать своё решение задания 2 предедущей практики!</strong></p>
<h2 id="Расширяем-интерфейс"><a class="header" href="#Расширяем-интерфейс">Расширяем интерфейс</a></h2>
<p>Теперь создадим новый интерфейс с поддержкой событий, который будет наследовать от нашего старого интерфейса <code>IMeasuringDevice</code>. Для этого нажмём <strong>(Ctrl + Shift + A)</strong> и создадим интерфейс IEventEnabledMeasuringDevice:</p>
<h3 id="ieventenabledmeasuringdevice"><a class="header" href="#ieventenabledmeasuringdevice">IEventEnabledMeasuringDevice</a></h3>
<pre><code class="language-C#">namespace MeasuringDevice
{  
    interface IEventEnabledMeasuringDevice : IMeasuringDevice
    {
        event EventHandler NewMeasurementTaken;
        // Событие, которое должно срабатывать при каждом Heartbeat
        event HeartBeatEventHandler HeartBeat;
        // Интервал Heartbeat, доступный только для чтения. Устанавливается только в конструкторе.
        int HeartBeatInterval { get; }
    }
}
</code></pre>
<blockquote>
<p>Создание нового интерфейса, расширяющего существующий интерфейс, является хорошей практикой программирования, поскольку при этом сохраняется структура исходного интерфейса для обеспечения обратной совместимости с ранее существовавшим кодом. Весь ранее существовавший код может ссылаться на исходный интерфейс, а новый код может ссылаться на новый интерфейс и использовать преимущества любых новых функций.</p>
</blockquote>
<p>Заметим, что <code>HeartBeatEventHandler</code> подчёркивается красным. Чтобы исправить это безобразие, добавим соответвующий делегат самостоятельно:</p>
<pre><code class="language-C#">//...
delegate void HeartBeatEventHandler();
// Делегат для события HeartBeat
//...
</code></pre>
<p>Также исправим тип <code>NewMeasurementTaken</code> <code>EventHandler</code> на <code>EventHandler?</code> чтобы избавиться от зелёной обводки. Таким образом VS говорит нам, <code>что NewMeasurementTaken</code> может быть <code>null</code>, но об этом позже.</p>
<p>Запустим приложение чтобы Microsoft IntelliSense® отражала наши изменения.</p>
<h2 id="Реализовываем-расширенный-интерфейс-в-абстрактном-классе-measuredatadevice"><a class="header" href="#Реализовываем-расширенный-интерфейс-в-абстрактном-классе-measuredatadevice">Реализовываем расширенный интерфейс в абстрактном классе MeasureDataDevice</a></h2>
<p>Теперь отправимся в <code>MeasureDataDevice</code> чтобы реализовать наш расширенный интерфейс. 
Далее нам нужно поменять строку:</p>
<pre><code class="language-C#">public abstract class MeasureDataDevice : IMeasuringDevice
</code></pre>
<p>на строку:</p>
<pre><code class="language-C#">public abstract class MeasureDataDevice : IEventEnabledMeasuringDevice
</code></pre>
<p>И тут же <code>IEventEnabledMeasuringDevice</code> было обведено красным. Жмём по нему, жмём <strong>(CTRL + '.')</strong>, выбираем реализовать интерфейс и нажимаем.</p>
<p>В нашем классе появляются такие две вещи:</p>
<pre><code class="language-C#">//...
public event EventHandler NewMeasurementTaken;

event IEventEnabledMeasuringDevice.HeartBeatEventHandler IEventEnabledMeasuringDevice.HeartBeat
{
    add
    {
        throw new NotImplementedException();
    }

    remove
    {
        throw new NotImplementedException();
    }
}
//...
</code></pre>
<p>Тут просто нужно убрать <code>throw new NotImplementedException();</code> и всё будет хорошо.</p>
<h2 id="Расширяем-абстрактный-класс-и-внедряем-работу-с-событиями"><a class="header" href="#Расширяем-абстрактный-класс-и-внедряем-работу-с-событиями">Расширяем абстрактный класс и внедряем работу с событиями</a></h2>
<p>Добавим protected virtual метод <code>OnNewMeasurementTaken</code>. Метод не должен принимать никаких параметров и иметь возвращаемый тип <code>void</code>. Класс <code>MeasureDataDevice</code> будет использовать этот метод для создания события <code>NewMeasurementTaken</code>.</p>
<pre><code class="language-C#">protected virtual void OnNewMeasurementTaken() { }
</code></pre>
<p>В методе <code>OnNewMeasurementTaken</code> самостоятельно добавим код для проверки наличия подписчика на событие <code>NewMeasurementTaken</code> Если такие имеются, нужно будет вызвать событие. Сигнатура делегата <code>EventHandler</code> определяет два параметра: типа object, указывающий объект, вызвавший событие, и параметр <code>EventArgs</code>, предоставляющий любые дополнительные данные, которые передаются обработчику событий. Зададим для объекта значение <code>this</code>, а для параметра <code>EventArgs</code> — значение null.</p>
<pre><code class="language-C#">protected virtual void OnNewMeasurementTaken() =&gt; NewMeasurementTaken?.Invoke(this, EventArgs.Empty);
</code></pre>
<p>Здесь оператор <code>?</code> проверяет <code>NewMeasurementTaken</code> на <code>null</code> и если <code>NewMeasurementTaken</code> не null, то вызывается соответствующее событие через <code>Invoke</code></p>
<blockquote>
<p>Примечание. Хорошей практикой программирования является проверка наличия подписчиков на событие перед его инициированием. Если у события нет подписчиков, связанный делегат имеет значение null, и среда выполнения .NET Framework выдаст исключение, если возникнет событие.</p>
</blockquote>
<h2 id="background-worker-ы"><a class="header" href="#background-worker-ы">Background worker-ы</a></h2>
<p>Самостоятельно добавим <code>private</code> поле типа <code>BackgroundWorker</code> с названием <code>dataCollector</code> в наш класс <code>MeasureDataDevice</code>;</p>
<pre><code class="language-C#">private BackgroundWorker dataCollector;
</code></pre>
<p>Далее нам придётся полностью переписать <code>GetMeasurments</code>. 
Делаем его приватным <code>void</code>, без параметров. Например, так:</p>
<pre><code class="language-C#">private void GetMeasurements() { }
</code></pre>
<p>В методе <code>GetMeasurements</code> самостоятельно добавим код для выполнения следующих действий:</p>
<ul>
<li>Создадим экземпляр элемента DataCollector BackgroundWorker.</li>
<li>Укажем, что член <code>DataCollector</code> <code>BackgroundWorker</code> поддерживает отмену.</li>
<li>Укажем, что член <code>DataCollector</code> <code>BackgroundWorker</code> сообщает о ходе выполнения во время работы.</li>
</ul>
<p>Для этого сперва создадим свойства <code>WorkerSupportsCancellation</code> и <code>WorkerReportsProgress</code>.
Их нужно задать в нашем абстрактном классе:</p>
<pre><code class="language-C#">public bool WorkerSupportsCancellation;
public bool WorkerReportsProgress;
</code></pre>
<p>Далее добавим следующий код в наш метод:</p>
<pre><code class="language-C#">dataCollector.DoWork += new DoWorkEventHandler(dataCollector_DoWork);
</code></pre>
<p>Данный код добавляет обработчик события <code>DoWork</code>, который вызывает наш пока ещё не реализованный метод <code>dataCollector_DoWork</code>. </p>
<p>Теперь похожим образом нужно самостоятельно реализовать обработчик события <code>ProgressChanged</code>. В качестве вызываемого метода будет выступать пока ещё не реализованный метод <code>dataCollector_ProgressChanged</code>:</p>
<pre><code class="language-C#">dataCollector.ProgressChanged += new ProgressChangedEventHandler(dataCollector_ProgressChanged);
</code></pre>
<p>Последний шаг перед реализацией необходимых методов - самостоятельно добавим код, запускающий нашего рабочего:</p>
<pre><code class="language-C#">dataCollector.RunWorkerAsync();
</code></pre>
<p>Теперь нам нужно реализовать сами методы. Сперва можно прокликать их и реализовать заглушки:</p>
<pre><code class="language-C#">private void dataCollector_ProgressChanged(object? sender, ProgressChangedEventArgs e)
{
    throw new NotImplementedException();
}

private void dataCollector_DoWork(object? sender, DoWorkEventArgs e)
{
    throw new NotImplementedException();
}
</code></pre>
<p>Код GetMeasurements, который получился в итоге:</p>
<h3 id="getmeasurements-2"><a class="header" href="#getmeasurements-2">GetMeasurements</a></h3>
<pre><code class="language-C#">public void GetMeasurements()
{

    dataCollector = new BackgroundWorker();
    WorkerReportsProgress = true;
    WorkerSupportsCancellation = true;

    dataCollector.DoWork += new DoWorkEventHandler(dataCollector_DoWork);
    dataCollector.ProgressChanged += new ProgressChangedEventHandler(dataCollector_ProgressChanged);

    dataCollector.RunWorkerAsync();
}
</code></pre>
<h2 id="Реализация-метода-datacollector_dowork"><a class="header" href="#Реализация-метода-datacollector_dowork">Реализация метода dataCollector_DoWork</a></h2>
<p>Под методом <code>GetMeasurements</code> найдите метод <code>dataCollector_DoWork</code>.</p>
<p>Этот метод мы создали во время выполнения предыдущей задачи. Он работает в фоновом потоке, и его целью является сбор и хранение данных измерений.</p>
<h3 id="В-методе-datacollector_dowork-необходимо-удалить-оператор-который-генерирует-исключение-notimplementedexception-и-добавить-код-для-выполнения-следующих-действий"><a class="header" href="#В-методе-datacollector_dowork-необходимо-удалить-оператор-который-генерирует-исключение-notimplementedexception-и-добавить-код-для-выполнения-следующих-действий">В методе dataCollector_DoWork() необходимо удалить оператор, который генерирует исключение NotImplementedException, и добавить код для выполнения следующих действий:</a></h3>
<ul>
<li>Создать массив <code>dataCaptured</code> с помощью нового целочисленного массива, который содержит 10 элементов. Определить целочисленную переменную <code>i</code> со значением нуля. Мы будем использовать эту переменную для отслеживания текущей позиции в массиве <code>dataCaptured</code>.</li>
<li>Добавить цикл <code>while</code>, который будет работать до тех пор, пока свойство <code>dataCollector.CancellationPending</code> будет равно <code>false</code>.</li>
</ul>
<h3 id="В-цикле-while-необходимо-добавить-код-для-выполнения-следующих-действий"><a class="header" href="#В-цикле-while-необходимо-добавить-код-для-выполнения-следующих-действий">В цикле while необходимо добавить код для выполнения следующих действий:</a></h3>
<ul>
<li>
<p>Вызвать метод <code>controller.TakeMeasurement()</code> и сохранить результат в массив <code>dataCaptured</code> по позиции, указанной целочисленной переменной <code>i</code>. Метод <code>TakeMeasurement()</code> объекта <code>controller</code> блокируется до тех пор, пока новое измерение не будет готово.</p>
</li>
<li>
<p>Обновить свойство <code>mostRecentMeasure</code>, чтобы оно содержало значение <code>dataCaptured</code> по позиции, указанной целочисленной переменной <code>i</code>.</p>
</li>
<li>
<p>Если значение переменной <code>disposed</code> равно <code>true</code>, завершить цикл <code>while</code>. Этот шаг гарантирует, что сбор измерений останавливается, когда объект <code>MeasureDataDevice</code> уничтожается.</p>
</li>
<li>
<p>Кстати, переменной <code>disposed</code> у нас никогда и не было, поэтому самостоятельно придумаем что это за переменная и куда её вставлять.</p>
</li>
</ul>
<p>Возможная реализация <code>disposed</code>:</p>
<pre><code class="language-C#">public bool disposed = false;  // Добавляем новое поле в класс MeasureDataDevice
// ...
public void StopCollecting()
{
    if (controller != null)
    {
        controller.StopDevice();
        controller = null;
    }
    disposed = true;  // Устанавливаем disposed как true в случае остановки сбора данных
}
</code></pre>
<p>Пока что в методе <code>dataCollector_DoWork</code> должно быть что-то похожее на это:</p>
<pre><code class="language-C#">private void dataCollector_DoWork(object? sender, DoWorkEventArgs e)
{
    dataCaptured = new int[10];
    int i = 0;

    while (dataCollector?.CancellationPending == false &amp;&amp; disposed == false)
    {
        dataCaptured[i] = controller != null ?
            controller.TakeMeasurement() : dataCaptured[i];
        mostRecentMeasure = dataCaptured[i];
    }
}
</code></pre>
<p>Идём дальше</p>
<h3 id="После-добавления-операторов-которые-мы-добавили-на-предедущем-шаге-необходимо-добавить-код-для-выполнения-следующих-действий"><a class="header" href="#После-добавления-операторов-которые-мы-добавили-на-предедущем-шаге-необходимо-добавить-код-для-выполнения-следующих-действий">После добавления операторов, которые мы добавили на предедущем шаге, необходимо добавить код для выполнения следующих действий:</a></h3>
<ul>
<li>
<p>Добавить в наш класс свойство <code>loggingFileWriter</code> типа <code>StreamWriter</code>, а также инициализировать его в методе <code>StartCollecting</code></p>
</li>
<li>
<p>Если свойство <code>loggingFileWriter</code> не равно <code>null</code>, вызвать метод <code>loggingFileWriter.WriteLine()</code>, передавая строковый параметр формата &quot;Measurement - mostRecentMeasure&quot;, где <code>mostRecentMeasure</code> - значение переменной <code>mostRecentMeasure</code>.</p>
</li>
<li>
<p>Добавить строку кода в конец цикла <code>while</code>, чтобы вызвать метод <code>dataCollector.ReportProgress()</code>, передавая ему ноль в качестве параметра.</p>
</li>
</ul>
<p>Метод <code>ReportProgress()</code> генерирует событие <code>ReportProgress</code> и обычно используется для возврата процента завершения задач, назначенных объекту <code>BackgroundWorker</code>. Мы можем использовать это событие для обновления индикаторов прогресса или оценок времени в пользовательском интерфейсе. Т. к. задача будет работать бесконечно до отмены, мы будем использовать это событие как механизм для запроса пользовательского интерфейса о обновлении отображения с новым измерением.</p>
<p>Добавим код в конец цикла <code>while</code> для выполнения следующих действий:</p>
<ul>
<li>Увеличить целочисленную переменную <code>i</code>.</li>
<li>Если значение целочисленной переменной больше 9, сбросить <code>i</code> в ноль.</li>
</ul>
<p>Мы используем целочисленную переменную <code>i</code> как указатель на следующую позицию, в которую нужно записать измерение, массива <code>dataCaptured</code>. Этот массив имеет место для 10 измерений. Когда элемент последний элемент заполнен (его индекс 9), устройство начнет перезаписывать данные с начала массива. </p>
<p>Возможная реализация <code>LoggingFileWriter</code></p>
<h4 id="loggingfilewriter"><a class="header" href="#loggingfilewriter">LoggingFileWriter</a></h4>
<pre><code class="language-C#">private StreamWriter? loggingFileWriter;
//...
public void StartCollecting()
{
    controller = DeviceController.StartDevice(measurementType);
    loggingFileWriter = new StreamWriter(&quot;log.txt&quot;);
    GetMeasurements();
}
</code></pre>
<p>Возможная реализация <code>dataCollector_DoWork</code>:</p>
<h4 id="datacollector_dowork"><a class="header" href="#datacollector_dowork">dataCollector_DoWork</a></h4>
<pre><code class="language-C#">private void dataCollector_DoWork(object? sender, DoWorkEventArgs e)
{
    dataCaptured = new int[10];
    int i = 0;

    while (dataCollector?.CancellationPending == false &amp;&amp; disposed == false)
    {
        dataCaptured[i] = controller != null ?
            controller.TakeMeasurement() : dataCaptured[i];
        mostRecentMeasure = dataCaptured[i];
        loggingFileWriter?.WriteLine($&quot;Measurement - {mostRecentMeasure}&quot;);
        dataCollector.ReportProgress(0);
        i = (i + 1) % 10;  // Когда в скобках будет значение 10, операция 10 % 10 даст 0, так это и работает.
    }
}
</code></pre>
<h2 id="Реализация-метода-datacollector_progresschanged"><a class="header" href="#Реализация-метода-datacollector_progresschanged">Реализация метода <code>dataCollector_ProgressChanged</code></a></h2>
<ul>
<li>Найдите в своём коде метод <code>dataCollector_ProgressChanged</code>.</li>
</ul>
<blockquote>
<p>Этот метод мы недавно добавили как заглушку. 
Он запускается при возникновении события <code>ProgressChanged</code>.
Это событие мы вызываем, когда метод dataCollector_DoWork принимает и сохраняет новое измерение.
Код, отвечающий за привязку метода <code>dataCollector_ProgressChanged</code>,
мы реализовали в <a href="practices/pr6/task1.html#getmeasurements">GetMeasurements</a></p>
</blockquote>
<ul>
<li>В методе удалите код, вызывающий исключение и затем вызовите метод <code>OnNewMeasurementTaken</code> без параметров.</li>
</ul>
<p>Должно получиться как-то так:</p>
<h4 id="datacollector_progresschanged"><a class="header" href="#datacollector_progresschanged">dataCollector_ProgressChanged</a></h4>
<pre><code class="language-C#">private void dataCollector_ProgressChanged(object? sender, ProgressChangedEventArgs e)
{
    OnNewMeasurementTaken();
}
</code></pre>
<blockquote>
<p>Метод <code>OnNewMeasurementTaken</code> вызывает событие <code>NewMeasurementTaken</code>,
определенное ранее. Мы можем изменить пользовательский интерфейс,
чтобы подписаться на это событие, чтобы при его возникновении пользовательский интерфейс
мог обновлять отображаемую информацию.</p>
</blockquote>
<h2 id="Доработка-нескольких-методов-и-проверка-кода"><a class="header" href="#Доработка-нескольких-методов-и-проверка-кода">Доработка нескольких методов и проверка кода</a></h2>
<ul>
<li>Убедимся, что в методе <code>StartCollecting</code> мы вызываем <a href="practices/pr6/task1.html#getmeasurements">GetMeasurements</a></li>
<li>в методе <code>StopCollecting</code>, если элемент <code>dataCollector</code> не является <code>null</code>,
нам нужно добавить вызов метода <code>CancelAsync</code>, чтобы остановить работу, выполняемую объектом <code>DataCollector BackgroundWorker</code>.</li>
<li>Создадим новый метод с названием <code>Dispose</code> в классе <code>MeasureDataDevice</code>, который будет вызывать <code>Dispose</code> на поле
<code>dataCollector</code>, в случае если <code>dataCollector</code> не равен <code>null</code>. Таким образом мы будем уничтожать наш фоновый сборщик данных при уничтожении экземпляра класса <code>MeasureDataDevice</code>.</li>
</ul>
<p>Вот возможная реализация вышеперечисленных трёх пунктов:</p>
<h3 id="startcollecting"><a class="header" href="#startcollecting">StartCollecting</a></h3>
<pre><code class="language-C#">public void StartCollecting()
{
    controller = DeviceController.StartDevice(measurementType);
    loggingFileWriter = new StreamWriter(&quot;log.txt&quot;);
    GetMeasurements();
}
</code></pre>
<h3 id="stopcollecting"><a class="header" href="#stopcollecting">StopCollecting</a></h3>
<pre><code class="language-C#">public void StopCollecting()
{
    if (controller != null)
    {
        controller.StopDevice();
        controller = null;
    }
    dataCollector?.CancelAsync();
    disposed = true;
}
</code></pre>
<h3 id="dispose"><a class="header" href="#dispose">Dispose</a></h3>
<pre><code class="language-C#">private void Dispose()
{
    dataCollector?.Dispose();
}
</code></pre>
<h2 id="Работа-с-ui"><a class="header" href="#Работа-с-ui">Работа с UI</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Приложение"><a class="header" href="#Приложение">Приложение</a></h1>
<p>Тут более подробно описаны различные концепты языка С#, которые были встречены в работах</p>
<h2 id="Основные-источники"><a class="header" href="#Основные-источники">Основные источники:</a></h2>
<ul>
<li><a href="https://learn.microsoft.com/ru-ru/dotnet/csharp/programming-guide">Официальная документация Microsoft</a></li>
<li><a href="https://metanit.com">Сайт Metanit.com</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visual-studio-хоткеи"><a class="header" href="#visual-studio-хоткеи">Visual studio хоткеи</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Хоткей</th><th>Назначение</th></tr></thead><tbody>
<tr><td>Ctrl+Shift+A</td><td>Создание нового элемента (класс, файл с кодом и т.п.)</td></tr>
<tr><td>Ctrl+'.'</td><td>При нажатии на кодовый элемент + сочетания клавиш  позволяет выбрать одно из возможных действий с элементом  вроде реализации абстрактного класса, интерфейса, конструктора и т.п.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="Интерфейсы"><a class="header" href="#Интерфейсы">Интерфейсы</a></h1>
<p>Интерфейс представляет ссылочный тип, который может определять некоторый функционал - набор методов и свойств без реализации (а после версии  C# 8.0 и с <a href="appendix/interfaces.html#%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE-%D1%83%D0%BC%D0%BE%D0%BB%D1%87%D0%B0%D0%BD%D0%B8%D1%8E">реализацией по умолчанию</a>). Затем этот функционал реализуют классы и структуры, которые применяют данные интерфейсы.
Для определения интерфейса используется ключевое слово <code>interface</code>. Как правило, названия интерфейсов в C# начинаются с заглавной буквы I, например, <code>IComparable</code>, <code>IEnumerable</code> (так называемая венгерская нотация), однако это не обязательное требование, а больше стиль программирования.
В целом интерфейсы могут определять следующие сущности:</p>
<ul>
<li>
<p>Методы</p>
</li>
<li>
<p>Свойства</p>
</li>
<li>
<p>Индексаторы</p>
</li>
<li>
<p>События</p>
</li>
<li>
<p>Статические поля и константы (начиная с версии C# 8.0)</p>
</li>
</ul>
<p>Простейший интерфейс, который определяет все эти компоненты:</p>
<pre><code class="language-C#">
interface IMovable
{
    // константа
    const int minSpeed = 0;     // минимальная скорость
    // статическая переменная
    static int maxSpeed = 60;   // максимальная скорость
    // метод
    void Move();                // движение
    // свойство
    string Name { get; set; }   // название
     
    delegate void MoveHandler(string message);  // определение делегата для события
    // событие
    event MoveHandler MoveEvent;    // событие движения
}
</code></pre>
<p>В данном случае определен интерфейс <code>IMovable</code>, который представляет некоторый движущийся объект. Интерфейс описывает некоторый функционал, который должен быть у движущегося объекта.</p>
<h2 id="Модификаторы-доступа"><a class="header" href="#Модификаторы-доступа">Модификаторы доступа</a></h2>
<p>В интерфейсе методы и свойства по умолчанию имеют модификатор <code>public</code>, так как цель интерфейса - определение функционала для реализации его классом. Сам интерфейс имеет модификатор доступа <code>internal</code> Мы могли бы обратиться к константе <code>minSpeed</code> и переменной <code>maxSpeed</code> интерфейса <code>IMovable</code>:</p>
<pre><code class="language-C#">Console.WriteLine(IMovable.maxSpeed);   // 60
Console.WriteLine(IMovable.minSpeed);   // 0
</code></pre>
<p>Но также, начиная с версии C# 8.0, мы можем явно указывать модификаторы доступа у компонентов интерфейса:</p>
<pre><code class="language-C#">interface IMovable
{
    public const int minSpeed = 0;     // минимальная скорость
    private static int maxSpeed = 60;   // максимальная скорость
    public void Move();
    protected internal string Name { get; set; }    // название
    public delegate void MoveHandler(string message);  // определение делегата для события
    public event MoveHandler MoveEvent;    // событие движения
}
</code></pre>
<p>Также с помощью модификатора public мы можем сделать интерфейс общедоступным:</p>
<pre><code class="language-C#">//...
public interface IMovable
//...
</code></pre>
<h2 id="Реализация-по-умолчанию"><a class="header" href="#Реализация-по-умолчанию">Реализация по умолчанию</a></h2>
<p>Также начиная с версии C# 8.0 интерфейсы поддерживают реализацию методов и свойств по умолчанию. Это значит, что мы можем определить в интерфейсах полноценные методы и свойства, которые имеют реализацию как в обычных классах и структурах. Например, определим реализацию метода Move по умолчанию:</p>
<pre><code class="language-C#">interface IMovable
{
    // реализация метода по умолчанию
    void Move()
    {
        Console.WriteLine(&quot;Walking&quot;);
    }
}
</code></pre>
<p>Стоит отметить, что если интерфейс имеет приватные методы и свойства (то есть с модификатором private), то они должны иметь реализацию по умолчанию. То же самое относится к статическим методам (не обязательно приватным):</p>
<pre><code class="language-C#">interface IMovable
{
    public const int minSpeed = 0;     // минимальная скорость
    private static int maxSpeed = 60;   // максимальная скорость
    // находим время, за которое надо пройти расстояние distance со скоростью speed
    static double GetTime(double distance, double speed) =&gt; distance / speed;
    static int MaxSpeed
    {
        get =&gt; maxSpeed;
        set
        {
            if (value &gt; 0) maxSpeed = value;
        }
    }
}
</code></pre>
<p>Благодаря интерфейсам, можно реализовать <a href="appendix/./multiple_interface_inherit.html">множественное наследование</a>, которое на самом деле называется композицией. </p>
<h2 id="Примеры-применения-интерфейсов"><a class="header" href="#Примеры-применения-интерфейсов">Примеры применения интерфейсов</a></h2>
<h3 id="Интерфейсы-без-реализации-по-умолчанию"><a class="header" href="#Интерфейсы-без-реализации-по-умолчанию">Интерфейсы без реализации по умолчанию</a></h3>
<pre><code class="language-C#">interface IMovable
{
    void Move();
}
class Person : IMovable
{
    public void Move() =&gt; Console.WriteLine(&quot;Человек идет&quot;);
}
struct Car : IMovable
{
    public void Move() =&gt; Console.WriteLine(&quot;Машина едет&quot;);
}

Person Tom = new Person();
Car Volga = new Car();
Tom.Move();  // Выведет: Человек идет
Volga.Move();  // Выведет: Машина едет
</code></pre>
<h3 id="Интефейсы-с-реализацией-по-умолчанию"><a class="header" href="#Интефейсы-с-реализацией-по-умолчанию">Интефейсы с реализацией по умолчанию</a></h3>
<pre><code class="language-C#">interface IMovable
{
    void Move() =&gt; Console.WriteLine(&quot;Walking&quot;);
}

class Person : IMovable { }

class Car : IMovable
{
    public void Move() =&gt; Console.WriteLine(&quot;Driving&quot;);
}

IMovable tom = new Person();
Car tesla = new Car();
tom.Move();     // Walking
tesla.Move();   // Driving
</code></pre>
<h2 id="Бонус-старый-синтаксис-интерфейсов-c-80"><a class="header" href="#Бонус-старый-синтаксис-интерфейсов-c-80">Бонус: старый синтаксис интерфейсов (C# &lt;8.0)</a></h2>
<pre><code class="language-C#">interface IMovable
{
    // минимальная скорость
    int minSpeed { get; set; }     
    // максимальная скорость
    int maxSpeed { get; set; }    
    // метод
    void Move();                // движение
    // свойство
    string Name { get; set; }   // название
}
</code></pre>
<p>Возможно, у вас возник вопрос, чем отличаются абстрактные классы от интерфейсов, тогда вам <a href="appendix/./abstract_classes_vs_interfaces.html">сюда</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Абстрактный-класс-1"><a class="header" href="#Абстрактный-класс-1">Абстрактный класс</a></h1>
<p>Абстрактные классы в C#. Для абстрактного класса такое создание объекта через new невозможно, т.к. абстрактный класс - это шаблон или базовый класс, который предназначен для наследования другими классами.
У абстрактных классов могут быть как <a href="appendix/abstract_class.html#%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B">абстрактные методы</a> (методы без реализации), так и не абстрактные методы. Если у класса есть хотя бы один абстрактный метод, то он должен быть объявлен как абстрактный.
Абстрактные классы могут использоваться в ситуациях, когда вы хотите определить набор общих поведений или свойств, которые должны быть реализованы производными классами (однако, если производный класс абстрактный, <a href="appendix/abstract_class.html#%D0%9E%D1%82%D0%BA%D0%B0%D0%B7-%D0%BE%D1%82-%D1%80%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D1%8B%D1%85-%D1%87%D0%BB%D0%B5%D0%BD%D0%BE%D0%B2">этого можно и не делать</a>).</p>
<p>Определив абстрактный класс, вы можете обеспечить согласованный интерфейс для всех классов, которые наследуются от него.</p>
<p>При определении абстрактных классов используется ключевое слово <code>abstract</code>. Например, определим абстрактный класс, который представляет некое транспортное средство:</p>
<pre><code class="language-C#">abstract class Transport
{
    public void Move()
    {
        Console.WriteLine(&quot;Транспортное средство движется&quot;);
    }
}
</code></pre>
<p>А также определим несколько производных классов</p>
<pre><code class="language-C#">// класс корабля
class Ship : Transport { }
// класс самолета
class Aircraft : Transport { }
// класс машины
class Car : Transport { }
</code></pre>
<pre><code class="language-C#">Transport car = new Car();
Transport ship = new Ship();
Transport aircraft = new Aircraft();
car.Move(); // Выведет: Транспортное средство движется
ship.Move(); // Выведет: Транспортное средство движется
aircraft.Move(); // Выведет: Транспортное средство движется
</code></pre>
<p>Транспортное средство представляет некоторую абстракцию, которая не имеет конкретного воплощения. То есть есть легковые и грузовые машины, самолеты, морские судна, кто-то на космическом корабле любит покататься, но как такового транспортного средства нет. Тем не менее все транспортные средства имеют нечто общее - они могут перемещаться. И для этого в классе определен метод Move, который эмулирует перемещение.</p>
<p>Главное отличие абстрактных классов от обычных состоит в том, что мы НЕ можем использовать конструктор абстрактного класса для создания экземпляра класса. Например, следующий код выдаст ошибку:</p>
<pre><code class="language-C#">Transport tesla = new Transport();  // Ошибка компиляции
</code></pre>
<h2 id="Конструкторы"><a class="header" href="#Конструкторы">Конструкторы</a></h2>
<p>Выше писалось, что мы не можем использовать конструктор абстрактного класса для создания экземпляра этого класса. Тем не менее такой класс также может определять конструкторы:</p>
<pre><code class="language-C#">abstract class Transport
{
    public string Name { get; }
    // конструктор абстрактного класса Transport
    public Transport(string name)
    {
        Name = name;
    }
    public void Move() =&gt;Console.WriteLine($&quot;{Name} движется&quot;);
}
</code></pre>
<p>В данном случае в абстрактном классе Transport определен конструктор - с помощью параметра он устанавливает значение свойства Name, которое хранит название транспортного средства. И в этом случае производные классы должны в своих конструкторах вызвать этот конструктор.</p>
<h2 id="Абстрактные-члены-классов"><a class="header" href="#Абстрактные-члены-классов">Абстрактные члены классов</a></h2>
<p>Кроме обычных свойств и методов абстрактный класс может иметь абстрактные члены классов, которые определяются с помощью ключевого слова <code>abstract</code> и не имеют никакого функционала. В частности, абстрактными могут быть:</p>
<ul>
<li>
<p><a href="appendix/abstract_class.html#%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B">Методы</a></p>
</li>
<li>
<p><a href="appendix/abstract_class.html#%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D1%8B%D0%B5-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0">Свойства</a></p>
</li>
<li>
<p>Индексаторы</p>
</li>
<li>
<p>События</p>
</li>
</ul>
<p>Абстрактные члены классов не должны иметь модификатор <code>private</code>. При этом производный класс обязан переопределить и реализовать все абстрактные методы и свойства, которые имеются в базовом абстрактном классе.</p>
<h3 id="Абстрактные-методы"><a class="header" href="#Абстрактные-методы">Абстрактные методы</a></h3>
<p>Например, выше в примере с транспортными средствами метод Move описывает передвижение транспортного средства. Однако различные типы транспорта перемещаются по разному - ездят по земле, летят по воздуху, плывут на воде и т.д. В этом случае мы можем сделать метод <code>Move</code> абстрактным.</p>
<pre><code class="language-C#">abstract class Transport
{
    public abstract void Move();
}
</code></pre>
<p>А его реализацию метода <code>Move</code> переложить на производные классы:</p>
<pre><code class="language-C#">class Ship : Transport 
{
    // мы должны реализовать все абстрактные методы и свойства базового класса
    public override void Move()
    {
        Console.WriteLine(&quot;Корабль плывет&quot;);
    }
}

class Aircraft : Transport
{
    public override void Move()
    {
        Console.WriteLine(&quot;Самолет летит&quot;);
    }
}

class Car : Transport
{
    public override void Move()
    {
        Console.WriteLine(&quot;Машина едет&quot;);
    }
}
</code></pre>
<p>Применение классов:</p>
<pre><code class="language-C#">Transport car = new Car();
Transport ship = new Ship();
Transport aircraft = new Aircraft();
 
car.Move();         // Выведет: Машина едет
ship.Move();        // Выведет: Корабль плывет
aircraft.Move();    // Выведет: Самолет летит
</code></pre>
<h3 id="Абстрактные-свойства"><a class="header" href="#Абстрактные-свойства">Абстрактные свойства</a></h3>
<p>Следует отметить использование абстрактных свойств:</p>
<pre><code class="language-C#">abstract class Transport
{
    // абстрактное свойство для хранения скорости
    public abstract int Speed { get; set; } 
}
</code></pre>
<p>Определим производный класс:</p>
<pre><code class="language-C#">class Ship: Transport
{
    int speed;
    public override int Speed 
    { 
        get =&gt; speed; 
        set =&gt; speed = value; 
    }
}
</code></pre>
<h3 id="Отказ-от-реализации-абстрактных-членов"><a class="header" href="#Отказ-от-реализации-абстрактных-членов">Отказ от реализации абстрактных членов</a></h3>
<p>Производный класс обязан реализовать все абстрактные члены базового класса. Однако мы можем отказаться от реализации, но в этом случае производный класс также должен быть определен как абстрактный:</p>
<pre><code class="language-C#">abstract class Transport
{
    public abstract void Move();
}
// класс машины
abstract class Car :Transport{}
</code></pre>
<p>Однако любые неабстрактные классы, производные от Car, все равно должны реализовать все унаследованные абстрактные методы и свойства:</p>
<pre><code class="language-C#">/// Класс легковой машины
class Auto: Car
{
    public override void Move()
    {
        Console.WriteLine(&quot;легковая машина едет&quot;);
    }
}

Transport tesla = new Auto();
tesla.Move();           // легковая машина едет
</code></pre>
<p>Возможно, у вас возник вопрос, чем отличаются абстрактные классы от интерфейсов, тогда вам <a href="appendix/./abstract_classes_vs_interfaces.html">сюда</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Множественное-наследование"><a class="header" href="#Множественное-наследование">Множественное наследование</a></h1>
<p>Множественное наследование относится к способности класса наследовать от нескольких базовых классов. C # не поддерживает множественное наследование классов, но он поддерживает множественное наследование с использованием интерфейсов. Это может быть полезно, когда нам нужно реализовать несколько абстракций и наследовать их свойства и методы.</p>
<pre><code class="language-C#">public interface I1
{
    void Method1();
}

public interface I2
{
    void Method2();
}

public interface I3
{
    void Method3();
}

public class MyClass : I1, I2, I3
{
    public void Method1()
    {
        Console.WriteLine(&quot;Method1 called&quot;);
    }

    public void Method2()
    {
        Console.WriteLine(&quot;Method2 called&quot;);
    }

    public void Method3()
    {
        Console.WriteLine(&quot;Method3 called&quot;);
    }
}
</code></pre>
<p>При таком наследовании может возникнуть проблема, что несколько интерфейсов определяют один и тот же метод. В таком случае в производном от этих интерфейсов классе можно применять <a href="appendix/./explicit_interfaces.html">явную реализацию интерфейсов</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Явная-реализация-интерфейсов-1"><a class="header" href="#Явная-реализация-интерфейсов-1">Явная реализация интерфейсов</a></h1>
<p>Если класс реализует два интерфейса, а интерфейсы содержат одинаковые методы, то возникает необходимость в явной реализации интерфейсов. Сначала рассмотрим проблемный код.</p>
<pre><code class="language-C#">// Определим интерфейсы
public interface IControl
{
    void Paint();
}
public interface ISurface
{
    void Paint();
}
// Попробуем их реализовать стандартным способом
public class SampleClass : IControl, ISurface
{
    // Оба ISurface.Paint и IControl.Paint вызывают данный метод
    public void Paint()
    {
        Console.WriteLine(&quot;Paint method in SampleClass&quot;);
    }
}
SampleClass sample = new SampleClass();
IControl control = sample;
ISurface surface = sample;

// Все эти строки вызовут один и тот же метод.
sample.Paint();
control.Paint();
surface.Paint();

// Вывод (О нет, он одинаковый):
// Paint method in SampleClass
// Paint method in SampleClass
// Paint method in SampleClass
</code></pre>
<p>А теперь, явная реализация. Сравните с кодом класса <code>SampleClass</code> выше, чтобы понять разницу.</p>
<pre><code class="language-C#">public class SampleClass : IControl, ISurface
{
    void IControl.Paint() // [интерфейс].[метод]
    {
        System.Console.WriteLine(&quot;IControl.Paint&quot;);
    }
    void ISurface.Paint() // Так и выглядит явная реализация интерфейсов
    {
        System.Console.WriteLine(&quot;ISurface.Paint&quot;);
    }
}
SampleClass sample = new SampleClass();
IControl control = sample;
ISurface surface = sample;

// Все эти строки вызовут один и тот же метод.
//sample.Paint(); // Compiler error.
control.Paint();  // Вызовет IControl.Paint на SampleClass.
surface.Paint();  // Вызовет ISurface.Paint на SampleClass.

// Так тоже можно
((IControl)sample).Study(); // Вызовет IControl.Paint на SampleClass.
((ISurface)sample).Study(); // Вызовет ISurface.Paint на SampleClass.

// Вывод:
// IControl.Paint
// ISurface.Paint
</code></pre>
<h2 id="Модификаторы-доступа-1"><a class="header" href="#Модификаторы-доступа-1">Модификаторы доступа</a></h2>
<p>Члены интерфейса могут иметь разные модификаторы доступа. Если модификатор доступа не <code>public</code>, а какой-то другой, то для реализации метода, свойства или события интерфейса в классах и структурах также необходимо использовать явную реализацию интерфейса.</p>
<pre><code class="language-C#">interface IMovable
{
    protected internal void Move();
    protected internal string Name { get;}
    delegate void MoveHandler();
    protected internal event MoveHandler MoveEvent;
}
class Person : IMovable
{
    string name;
    // явная реализация события - дополнительно создается переменная
    IMovable.MoveHandler? moveEvent;
    event IMovable.MoveHandler IMovable.MoveEvent
    {
        add =&gt; moveEvent += value;
        remove =&gt; moveEvent -= value;
    }
    // явная реализация свойства - в виде автосвойства
    string IMovable.Name { get =&gt; name; }
    public Person(string name) =&gt; this.name = name;
    // явная реализация метода
    void IMovable.Move()
    {
        Console.WriteLine($&quot;{name} is walking&quot;);
        moveEvent?.Invoke();
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Абстрактные-классы-vs-интерфейсы"><a class="header" href="#Абстрактные-классы-vs-интерфейсы">Абстрактные классы vs интерфейсы</a></h1>
<h2 id="Преимущества-абстрактного-класса"><a class="header" href="#Преимущества-абстрактного-класса">Преимущества абстрактного класса:</a></h2>
<ul>
<li>Добавление проверки <a href="https://learn.microsoft.com/ru-ru/dotnet/framework/debug-trace-profile/code-contracts#:~:text=%D0%98%D0%BD%D0%B2%D0%B0%D1%80%D0%B8%D0%B0%D0%BD%D1%82%D1%8B%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2%20%E2%80%94%20%D1%8D%D1%82%D0%BE%20%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D1%8F%2C,%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D1%86%D0%B8%D1%80%D1%83%D1%8E%D1%82%D1%81%D1%8F%20%D0%BF%D0%BE%20%D0%BF%D0%BE%D0%BC%D0%B5%D1%82%D0%BA%D0%B5%20%D0%B0%D1%82%D1%80%D0%B8%D0%B1%D1%83%D1%82%D0%BE%D0%BC%20ContractInvariantMethodAttribute">инвариантов</a> в функции</li>
<li><a href="https://stackoverflow.com/questions/9143106/advantage-of-abstract-class-over-interface">После изменения абстрактного класса, код наследников автоматически изменяется</a></li>
<li>Возможность объявлять конструкторы</li>
<li>Члены класса могут быть определены как <code>abstract</code>, <code>virtual</code>, <code>static</code>, или <code>sealed</code>.</li>
<li>Способен иметь не только константные поля.</li>
</ul>
<p>Интерфейсы являются просто контрактами передачи данных и не имеют этих функций. Однако они обычно более гибкие, так как тип может быть произведен только из одного класса, но может реализовывать любое количество интерфейсов, тоесть мы можем реализовать <a href="appendix/./multiple_interface_inherit.html">множественное наследование интерфейсов</a>.</p>
<h2 id="Дополнительные-преимущества-абстрактного-класса-до-c80"><a class="header" href="#Дополнительные-преимущества-абстрактного-класса-до-c80">Дополнительные преимущества абстрактного класса до C#8.0:</a></h2>
<ul>
<li>Возможность указания реализации по умолчанию методов</li>
<li>Абстрактный класс может содержать поля и константы.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Справка-по-проектированию-с-использованием-абстрактных-классов-и-интерфейсов"><a class="header" href="#Справка-по-проектированию-с-использованием-абстрактных-классов-и-интерфейсов">Справка по проектированию с использованием абстрактных классов и интерфейсов</a></h1>
<p>Интерфейсы могут быть удобны при проектировании приложений, так как можно обозначить функционал, которым будущее приложение должно будет обладать, примерную структуру приложения, типы, после чего его можно реализовать хотя бы заглушками и уже это спасёт вам не один час. С грамотными заглушками приложение можно будет тестировать и запускать с самого начала, а низкая связность интерфейсов позволят работать над изолированными частями приложения сразу нескольким программистам параллельно, программистам зачастую не нужно смотреть код других интерфейсов, чтобы делать свой. Технический руководитель может не знать, какова точная бизнес-логика, но с помощью интерфейса может наглядно продемонстрировать своё виденье проекта всем программистам, работающим с классами.</p>
<p>Интерфейсы также могут быть полезны при проектировании приложений, где важно параллельное программирование, из за своей низкой связности.</p>
<p>Далее, интерфейсы можно объединять в единые сущности как абстрактные классы, чтобы потом от них наследовали более конкретные сущности. При этом использование интерфейсов и абстрактных классов избавит от необходимости построения сложной иерархии наследования, что в свою очередь уменьшит количества кода, который придётся изменять как разработчикам приложений при внедрении новых фич, так и пользователям библиотек когда библиотеки будут изменятся. </p>
<h2 id="Когда-следует-использовать-абстрактные-классы"><a class="header" href="#Когда-следует-использовать-абстрактные-классы">Когда следует использовать абстрактные классы:</a></h2>
<ul>
<li>
<p>Если надо определить общий функционал для родственных объектов</p>
</li>
<li>
<p>Если нужно, чтобы все производные классы на всех уровнях наследования имели некоторую общую реализацию. 
При использовании абстрактных классов, если мы захотим изменить базовый функционал во всех наследниках, то достаточно поменять его в абстрактном базовом классе.</p>
</li>
<li>
<p>Если же нам вдруг надо будет поменять название или параметры метода интерфейса, то придется вносить изменения и также во всех классы, которые данный интерфейс реализуют.</p>
</li>
</ul>
<h2 id="Когда-следует-использовать-интерфейсы"><a class="header" href="#Когда-следует-использовать-интерфейсы">Когда следует использовать интерфейсы:</a></h2>
<ul>
<li>
<p>Если нам надо определить функционал для группы разрозненных объектов, которые могут быть никак не связаны между собой.</p>
</li>
<li>
<p>Если мы проектируем большой громоздкий тип, то лучше будет разбить его на мелкие интерфейсы, после чего собрать их в одном абстрактном классе.</p>
</li>
<li>
<p>Если мы находимся на стадии проектирования нашего приложения и хотим запустить частично рабочую версию максимально быстро, при этом собрав примерную картину нашего приложения без конкретной пока реализации.</p>
</li>
</ul>
<p>Таким образом, если разноплановые классы обладают каким-то общим действием, то это действие лучше выносить в интерфейс. А для одноплановых классов, которые имеют общее состояние, оптимально определить абстрактный класс.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Делегаты-1"><a class="header" href="#Делегаты-1">Делегаты</a></h1>
<p>Делегаты - это указатели на методы и с помощью делегатов мы можем вызвать методы по указателю.</p>
<h2 id="Определение-делегатов-1"><a class="header" href="#Определение-делегатов-1">Определение делегатов</a></h2>
<p>Для объявления делегата используется ключевое слово <code>delegate</code>, после которого идет возвращаемый тип, название и параметры. Например:</p>
<pre><code class="language-C#">delegate void Message();
</code></pre>
<p>Делегат <code>Message</code> в качестве возвращаемого типа имеет тип <code>void</code> (то есть ничего не возвращает) и не принимает никаких параметров. Это значит, что этот делегат может указывать на любой метод, который не принимает никаких параметров и ничего не возвращает.</p>
<p>Рассмотрим примение этого делегата:</p>
<pre><code class="language-C#">using System;

public class Program
{
    static void Hello() =&gt; Console.WriteLine(&quot;Amogus ඞ&quot;);  // Объявляем метод
    delegate void Message();  // Объявляем делегат

    public static void Main()
    {
        Message mes = Hello;      // Присваиваем переменной mes адрес метода Hello
        mes();                    // Вызываем метод Hello, выведет: Amogus ඞ
    }
}
</code></pre>
<p>При этом делегаты также могут указывать на методы, определённые в других классах и структурах:</p>
<pre><code class="language-C#">using System;

public class Amogus 
{
	public static void Hello() =&gt; Console.WriteLine(&quot;Amogus ඞ&quot;);
}

public class Program
{
    void Hello() =&gt; Console.WriteLine(&quot;Amogus ඞ&quot;); 
    delegate void Message(); 

    public static void Main()
    { 
        Message mes = Amogus.Hello;    
        mes();                      // Вызываем метод Hello, выведет: Amogus ඞ
    }
}
</code></pre>
<h2 id="Параметры-и-результат-делегата"><a class="header" href="#Параметры-и-результат-делегата">Параметры и результат делегата</a></h2>
<p>Рассмотрим определение и применение делегата, который принимает параметры и возвращает результат:</p>
<pre><code class="language-C#">using System;

public class Calculator
{
	public static int Add(int x, int y) =&gt; x + y;
	public static int Multiply(int x, int y) =&gt; x * y;
}

public class Program
{
    delegate int Operation(int x, int y);

    public static void Main()
    { 
		Operation op = Calculator.Add;
		Console.WriteLine(op(1, 2));  // 3
		op = Calculator.Multiply;
		Console.WriteLine(op(1, 2));  // 2
    }
}
</code></pre>
<p>В данном случае делегат <code>Operation</code> возвращает значение типа <code>int</code> и имеет два параметра типа <code>int</code>. Поэтому такому делегату соответствует любой метод, который возвращает значение типа <code>int</code> и принимает два параметра типа <code>int</code>. В данном случае это методы <code>Add</code> и <code>Multiply</code>. То есть мы можем присвоить переменной делегата любой из этих методов и вызывать.</p>
<h2 id="Присвоение-ссылки-на-метод"><a class="header" href="#Присвоение-ссылки-на-метод">Присвоение ссылки на метод</a></h2>
<p>Выше переменной делегата напрямую присваивался метод. Есть еще один способ - создание объекта делегата с помощью конструктора, в который передается нужный метод:</p>
<pre><code class="language-C#">//...
Operation operation1 = Add;
Operation operation2 = new Operation(Add);
//...
</code></pre>
<p>Оба способа равноценны.</p>
<h2 id="Соответствие-методов-делегату"><a class="header" href="#Соответствие-методов-делегату">Соответствие методов делегату</a></h2>
<p><code>ref</code>, <code>in</code> и <code>out</code> также определяют сигнатуру делегата:</p>
<pre><code class="language-C#">delegate void SomeDel(int a, double b);

void SomeMethod1(int g, double n) { };  // Соответствует делегату
double SomeMethod2(int g, double n) { return g + n; }  // Не соответствует делегату
void SomeMethod3(out int g, double n) { g = 6; }  // Не соответствует делегату
</code></pre>
<h2 id="Добавление-методов-в-делегат"><a class="header" href="#Добавление-методов-в-делегат">Добавление методов в делегат</a></h2>
<p>В примерах выше переменная делегата указывала на один метод. В реальности же делегат может указывать на множество методов, которые имеют ту же сигнатуру и возвращаемый тип. Все методы в делегате попадают в специальный список - список вызова или <strong>invocation list</strong>. При вызове делегата все методы из этого списка последовательно вызываются. Для добавления методов в делегат применяется операция +=:</p>
<pre><code class="language-C#">Message message = Hello;
message += HowAreYou;  // теперь message указывает на два метода
message();              // вызываются оба метода - Hello и HowAreYou
 
void Hello() =&gt; Console.WriteLine(&quot;Hello&quot;);
void HowAreYou() =&gt; Console.WriteLine(&quot;How are you?&quot;);
 
delegate void Message();  // Выведет на одной строке Hello, на другой: How are you?
</code></pre>
<p>Делегаты, которые включают в себя больше одного метода, называют <strong>мультикаст-делегатами</strong>.</p>
<p>При добавлении методов, которые возвращают какой-то результат, делегат вернёт результат последнего метода:</p>
<pre><code class="language-C#">using System;

public class Calculator
{
	public static int Add(int x, int y) {
		Console.WriteLine(&quot;Gonna do some math&quot;);
		return x + y;
	}
	public static int Multiply(int x, int y) =&gt; x * y;
}

public class Program
{
    delegate int Operation(int x, int y);

    public static void Main()
    { 
		Operation op = Calculator.Add;
		op += Calculator.Multiply;
		Console.WriteLine(op(1, 2));  // Выведет на одной строке: Gonna do some math, на другой строке: 2
    }
}
</code></pre>
<h2 id="Удаление-методов-из-делегата"><a class="header" href="#Удаление-методов-из-делегата">Удаление методов из делегата</a></h2>
<p>Мы можем удалять методы из делегата с помощью операций -=:</p>
<pre><code class="language-C#">Message? message = Hello; 
message += HowAreYou;
message();  // вызываются все методы из message
message -= HowAreYou;   // удаляем метод HowAreYou
if (message != null) message(); // вызывается метод Hello
</code></pre>
<p>Стоит отметить, что при удалении метода может сложиться ситуация, что в делегате не будет методов, и тогда переменная будет иметь значение <code>null</code>. Поэтому в данном случае переменная определена не просто как переменная типа <code>Message</code>, а именно <code>Message?</code>, то есть типа, который может представлять как делегат <code>Message</code>, так и значение <code>null</code>.</p>
<p>Кроме того, перед вторым вызовом мы проверяем переменную на значение <code>null</code>.</p>
<p>При удалении следует учитывать, что если делегат содержит несколько ссылок на один и тот же метод, то операция -= начинает поиск с конца списка вызова делегата и удаляет только первое найденное вхождение. Если подобного метода в списке вызова делегата нет, то операция -= не имеет никакого эффекта.</p>
<h2 id="Метод-invoke"><a class="header" href="#Метод-invoke">Метод Invoke()</a></h2>
<p>Также делегат можно вызвать через <code>Invoke</code> - такой метод есть у всех делегатов и это всеравно что вызвать сам делегат. <code>Invoke</code> полезен при проверке делегатов на <code>null</code> через оператор ?:</p>
<pre><code class="language-C#">Message? mes = Hello;
mes?.Invoke(); // Amogus ඞ&quot;
</code></pre>
<h2 id="Объединение-делегатов"><a class="header" href="#Объединение-делегатов">Объединение делегатов</a></h2>
<pre><code class="language-C#">Message mes1 = Hello;
Message mes2 = HowAreYou;
Message mes3 = mes1 + mes2; // объединяем делегаты
mes3(); // вызываются все методы из mes1 и mes2
 
void Hello() =&gt; Console.WriteLine(&quot;Hello&quot;);
void HowAreYou() =&gt; Console.WriteLine(&quot;How are you?&quot;);
 
delegate void Message();
</code></pre>
<p>В данном случае объект <code>mes3</code> представляет объединение делегатов <code>mes1</code> и <code>mes2</code>. Объединение делегатов значит, что в список вызова делегата <code>mes3</code> попадут все методы из делегатов <code>mes1</code> и <code>mes2</code>. И при вызове делегата <code>mes3</code> все эти методы одновременно будут вызваны.</p>
<h2 id="Обобщённые-делегаты"><a class="header" href="#Обобщённые-делегаты">Обобщённые делегаты</a></h2>
<p>Делегаты, как и другие типы, могут быть обобщенными (написаны через генерики), например:</p>
<pre><code class="language-C#">delegate T Operation&lt;T&gt;(T val);
int Double(int n) =&gt; n + n;

Operation&lt;int&gt; doubleOperation = Double;
Console.WriteLine(doubleOperation(5));  // 10
</code></pre>
<h2 id="Делегаты-как-параметры-методов"><a class="header" href="#Делегаты-как-параметры-методов">Делегаты как параметры методов</a></h2>
<p>Также делегаты могут быть параметрами методов. Например:</p>
<pre><code class="language-C#">delegate int Operation(int x, int y);

int Add(int x, int y) =&gt; x + y;

void DoOperation(int a, int b, Operation op)
{
    Console.WriteLine(op(a,b));
}

DoOperation(5, 4, Add);  // 9
</code></pre>
<h2 id="Возвращение-делегатов-из-метода"><a class="header" href="#Возвращение-делегатов-из-метода">Возвращение делегатов из метода</a></h2>
<p>Делегаты можно возвращать из методов. То есть мы можем возвращать из метода какое-то действие в виде другого метода. Например:</p>
<pre><code class="language-C#">delegate int Operation(int x, int y);
 
int Add(int x, int y) =&gt; x + y;
int Subtract(int x, int y) =&gt; x - y;
int Multiply(int x, int y) =&gt; x * y;

enum OperationType
{
    Add, Subtract, Multiply
}

Operation SelectOperation(OperationType opType)
{
    switch (opType)
    {
        case OperationType.Add: return Add;
        case OperationType.Subtract: return Subtract;
        default: return Multiply;
    }
}

Operation operation = SelectOperation(OperationType.Add);
Console.WriteLine(operation(10, 4));    // 14
</code></pre>
<p>Делегатами также являются и лямбда выражения, но это уже <a href="appendix/./lambda.html">отдельная тема</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Лямбда-выражения-1"><a class="header" href="#Лямбда-выражения-1">Лямбда выражения</a></h1>
<p>Лямбда-выражения представляют упрощенную запись анонимных методов. Лямбда-выражения позволяют создать емкие лаконичные методы, которые могут возвращать некоторое значение и которые можно передать в качестве параметров в другие методы.</p>
<p>С точки зрения типа данных лямбда-выражение представляет <a href="appendix/./delegate.html">делегат</a>. Например, определим простейшее лямбда-выражение:</p>
<pre><code class="language-C#">delegate void Message();
Message hello = () =&gt; Console.WriteLine(&quot;Hello&quot;);
hello();  // Hello
</code></pre>
<p>Если лямбда-выражение содержит несколько действий, то они помещаются в фигурные скобки:</p>
<pre><code class="language-C#">Message hello = () =&gt;
{
    Console.Write(&quot;Hello &quot;);
    Console.WriteLine(&quot;World&quot;);
};
hello();  // Hello World
</code></pre>
<h2 id="Неявная-типизация"><a class="header" href="#Неявная-типизация">Неявная типизация</a></h2>
<p>Начиная с версии C# 10 мы можем применять неявную типизацию (определение переменной с помощью оператора <code>var</code>) при определении лямбда-выражения:</p>
<pre><code class="language-C#">var hello = () =&gt; Console.WriteLine(&quot;Hello&quot;);
hello();  // Hello
</code></pre>
<p>Но какой тип в данном случае представляет переменная <code>hello</code>? При неявной типизации компилятор сам пытается сопоставить лямбда-выражение на основе его определения с каким-нибудь делегатом. Например, выше определенное лямбда-выражение <code>hello</code> по умолчанию компилятор будет рассматривать как переменную встроенного делегата <code>Action</code>, который не принимает никаких параметров и ничего не возвращает.</p>
<h2 id="Параметры-лямбды"><a class="header" href="#Параметры-лямбды">Параметры лямбды</a></h2>
<p>При определении списка параметров мы можем не указывать для них тип данных:</p>
<pre><code class="language-C#">delegate void Operation(int x, int y);

Operation sum = (x, y) =&gt; Console.WriteLine($&quot;{x} + {y} = {x + y}&quot;);
sum(1, 2);       // 1 + 2 = 3
</code></pre>
<p>В данном случае компилятор видит, что лямбда-выражение sum представляет тип <code>Operation</code>, а значит оба параметра лямбды представляют тип <code>int</code>. Поэтому никак проблем не возникнет.</p>
<p>Однако если мы применяем неявную типизацию, то у компилятора могут возникнуть трудности, чтобы вывести тип делегата для лямбда-выражения, например, в следующем случае:</p>
<pre><code class="language-C#">var sum = (x, y) =&gt; Console.WriteLine($&quot;{x} + {y} = {x + y}&quot;);   // ! Ошибка
</code></pre>
<p>В этом случае нужно явно указать тип параметров:</p>
<pre><code class="language-C#">var sum = (int x, int y) =&gt; Console.WriteLine($&quot;{x} + {y} = {x + y}&quot;);
sum(22, 14);    // 22 + 14 = 36
</code></pre>
<h2 id="Возвращение-результата"><a class="header" href="#Возвращение-результата">Возвращение результата</a></h2>
<p>Лямбда-выражение может возвращать результат. Возвращаемый результат можно указать после лямбда-оператора:</p>
<pre><code class="language-C#">var sum = (int x, int y) =&gt; x + y;
Console.WriteLine(sum(4, 5));  // 9
</code></pre>
<p>Если лямбда-выражение содержит несколько выражений, тогда нужно использовать оператор <code>return</code>, как в обычных методах:</p>
<pre><code class="language-C#">var subtract = (int x, int y) =&gt;
{
    if (x &gt; y) return x - y;
    else return y - x;
};

Console.WriteLine(subtract(10, 6));     // 4
</code></pre>
<h2 id="Добавление-и-удаление-действий-в-лямбда-выражении"><a class="header" href="#Добавление-и-удаление-действий-в-лямбда-выражении">Добавление и удаление действий в лямбда-выражении</a></h2>
<p>Поскольку лямбда-выражение представляет делегат, тот как и в делегат, в переменную, которая представляет лямбда-выражение можно добавлять методы и другие лямбды:</p>
<pre><code class="language-C#">var message = () =&gt; Console.Write(&quot;Hello &quot;);
for (int i = 1; i &lt; 10; i++) {
    message += message;
}
message();  // 512 раз выведет Hello через пробел
</code></pre>
<p>Лямбды также можно удалять:</p>
<pre><code class="language-C#">var message = () =&gt; Console.Write(&quot;Hello &quot;);
var world = () =&gt; Console.Write(&quot;World!&quot;);
var meow = () =&gt; Console.Write(&quot;Meow! &quot;);
message += world;
message += meow;  // Добавляем Meow
message -= world;  // Уничтожаем мир с помощью C#
message();  // Hello Meow!
</code></pre>
<p>Как и делегаты, лямбда-выражения можно передавать параметрам метода, которые представляют делегат.</p>
<pre><code class="language-C#">int[] nums = {1, 2, 3, 4};
nums = nums.Where((num) =&gt; num % 2 == 0).ToArray();
foreach (int element in nums)
    Console.Write(element + &quot; &quot;); // 2 4
</code></pre>
<h2 id="Лямбда-выражение-как-результат-метода"><a class="header" href="#Лямбда-выражение-как-результат-метода">Лямбда-выражение как результат метода</a></h2>
<p>Метод также может возвращать лямбда-выражение. В этом случае возвращаемым типом метода выступает делегат, которому соответствует возвращаемое лямбда-выражение.</p>
<pre><code class="language-C#">delegate int Operation(int x, int y);

enum OperationType
{
    Add, Subtract, Multiply
}

Operation SelectOperation(OperationType opType)
{
    switch (opType)
    {
        case OperationType.Add: return (x, y) =&gt; x + y;
        case OperationType.Subtract: return (x, y) =&gt; x - y;
        default: return (x, y) =&gt; x * y;
    }
}

Operation operation = SelectOperation(OperationType.Add);
Console.WriteLine(operation(10, 4));    // 14
 
operation = SelectOperation(OperationType.Subtract);
Console.WriteLine(operation(10, 4));    // 6
 
operation = SelectOperation(OperationType.Multiply);
Console.WriteLine(operation(10, 4));    // 40
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="События-и-их-обработчики"><a class="header" href="#События-и-их-обработчики">События и их обработчики</a></h1>
<h2 id="Определение-и-вызов-событий"><a class="header" href="#Определение-и-вызов-событий">Определение и вызов событий</a></h2>
<p>События — это особый вид многоадресного делегата, который может вызываться только из класса (или производных классов) или структуры, где они объявлены (класс издателя).</p>
<p>События объявляются в классе с помощью ключевого слова <code>event</code>, после которого указывается тип делегата, который представляет событие:</p>
<pre><code class="language-C#">delegate void AccountHandler(string message);
event AccountHandler Notify;
</code></pre>
<p>В данном случае вначале определяется делегат <code>AccountHandler</code>, который принимает один параметр типа <code>string</code>. Затем с помощью ключевого слова <code>event</code> определяется событие с именем <code>Notify</code>, которое представляет делегат <code>AccountHandler</code>. Название для события может быть произвольным, но в любом случае оно должно представлять некоторый делегат.</p>
<p>Определив событие, мы можем его вызвать в программе как метод, используя имя события:</p>
<pre><code class="language-C#">Notify(&quot;Произошло действие&quot;);
</code></pre>
<p>Поскольку событие <code>Notify</code> представляет делегат <code>AccountHandler</code>, который принимает один параметр типа <code>string</code> - строку, то при вызове события нам надо передать в него строку.</p>
<p>Однако при вызове событий мы можем столкнуться с тем, что событие равно <code>null</code> в случае, если для его не определен обработчик. Поэтому при вызове события лучше его всегда проверять на <code>null</code>. Например, так:</p>
<pre><code class="language-C#">Notify?.Invoke(&quot;Произошло действие&quot;);
</code></pre>
<p>В этом случае поскольку событие представляет делегат, то мы можем его вызвать с помощью метода <a href="appendix/./delegate.html#%D0%9C%D0%B5%D1%82%D0%BE%D0%B4-invoke">Invoke()</a>, передав в него необходимые значения для параметров.</p>
<p>Создадим и вызовем событие:</p>
<pre><code class="language-C#">class Account
{
    // В делегате определяем как будет выглядеть наше событие
    public delegate void AccountHandler(string message);

    // 1. Определение события
    public event AccountHandler? Notify;

    // Конструктор через лямбда выражение
    public Account(int sum) =&gt; Sum = sum;

    public int Sum { get; private set; }

    public void Put(int sum)
    {
        Sum += sum;
        Notify?.Invoke($&quot;На счет поступило: {sum}&quot;);   // 2.Вызов события 
    }

    public void Take(int sum)
    {
        if (Sum &gt;= sum)
        {
            Sum -= sum;
            Notify?.Invoke($&quot;Со счета снято: {sum}&quot;);   // 2.Вызов события
        }
        else
        {
            Notify?.Invoke($&quot;Недостаточно денег на счету. Текущий баланс: {Sum}&quot;); ;
        }
    }
}
</code></pre>
<h2 id="Добавление-обработчика-события"><a class="header" href="#Добавление-обработчика-события">Добавление обработчика события</a></h2>
<p>С событием может быть связан один или несколько обработчиков. Обработчики событий - это именно то, что выполняется при вызове событий. Нередко в качестве обработчиков событий применяются методы. Каждый обработчик событий по списку параметров и возвращаемому типу должен соответствовать делегату, который представляет событие. Для добавления обработчика события применяется операция +=:</p>
<p>Определим обработчики для события <code>Notify</code>, чтобы получить в программе нужные уведомления:</p>
<pre><code class="language-C#">void DisplayMessage(string message) =&gt; Console.WriteLine(message);
Account account = new Account(100);
account.Notify += DisplayMessage;   // Добавляем обработчик для события Notify

account.Put(20);    // добавляем на счет 20
// Наш обработчик перехватит событие, произошедшее в методе account.Put и выведет: На счет поступило: 20
</code></pre>
<p>При вызове события <code>Notify?.Invoke()</code> будет вызываться метод <code>DisplayMessage</code>, которому для параметра message будет передаваться строка, которая передается в <code>Notify?.Invoke()</code>. В <code>DisplayMessage</code> просто выводим полученное от события сообщение, но можно было бы определить любую логику.</p>
<p>Если бы в данном случае обработчик не был бы установлен, то при вызове события <code>Notify?.Invoke()</code> ничего не происходило, так как событие <code>Notify</code> было бы равно <code>null</code>.</p>
<h2 id="Добавление-и-удаление-обработчиков"><a class="header" href="#Добавление-и-удаление-обработчиков">Добавление и удаление обработчиков</a></h2>
<p>Для одного события можно установить несколько обработчиков и потом в любой момент времени их удалить.</p>
<pre><code class="language-C#">void DisplayMessage(string message) =&gt; Console.WriteLine(message);
void DisplayBoldMessage(string message) =&gt; Console.WriteLine($&quot;**{message}**&quot;);

Account account = new Account(100);
account.Notify += DisplayMessage;       // добавляем обработчик DisplayMessage
account.Notify += DisplayBoldMessage;    // добавляем обработчик DisplayRedMessage
account.Put(20);    // добавляем на счет 20
account.Notify -= DisplayBoldMessage;     // удаляем обработчик DisplayRedMessage
account.Put(50);    // добавляем на счет 50
</code></pre>
<pre><code class="language-console">На счет поступило: 20
**На счет поступило: 20**
На счет поступило: 50
</code></pre>
<p>В качестве обработчиков могут использоваться не только обычные методы, но также делегаты, анонимные методы и лямбда-выражения:</p>
<pre><code class="language-C#">void DisplayMessage(string message) =&gt; Console.WriteLine(message);

Account acc = new Account(100);
// установка делегата, который указывает на метод DisplayMessage
acc.Notify += new Account.AccountHandler(DisplayMessage);
// установка в качестве обработчика метода DisplayMessage
acc.Notify += DisplayMessage;       // добавляем обработчик DisplayMessage
 
acc.Put(20);    // добавляем на счет 20
</code></pre>
<p>В данном случае разницы между двумя обработчиками никакой не будет.</p>
<p>Установка в качестве обработчика анонимного метода:</p>
<pre><code class="language-C#">Account acc = new Account(100);
acc.Notify += delegate (string mes)
{
    Console.WriteLine(mes);
};
acc.Put(20);
</code></pre>
<p>Установка в качестве обработчика лямбда-выражения:</p>
<pre><code class="language-C#">Account account = new Account(100);
account.Notify += message =&gt; Console.WriteLine(message);
account.Put(20);
</code></pre>
<h2 id="Управление-обработчиками"><a class="header" href="#Управление-обработчиками">Управление обработчиками</a></h2>
<p>С помощью специальных акссесоров <code>add</code>/<code>remove</code> мы можем управлять добавлением и удалением обработчиков. Как правило, подобная функциональность редко требуется, но тем не менее мы ее можем использовать. Например:</p>
<pre><code class="language-C#">class Account
{
    public delegate void AccountHandler(string message);
    AccountHandler? notify;
    public event AccountHandler Notify
    {
        add
        {
            notify += value;
            Console.WriteLine($&quot;{value.Method.Name} добавлен&quot;);
        }
        remove
        {
            notify -= value;
            Console.WriteLine($&quot;{value.Method.Name} удален&quot;);
        }
    }
    public Account(int sum) =&gt; Sum = sum;
    public int Sum { get; private set; }
    public void Put(int sum)
    {
        Sum += sum;
        notify?.Invoke($&quot;На счет поступило: {sum}&quot;);   // 2.Вызов события 
    }
    public void Take(int sum)
    {
        if (Sum &gt;= sum)
        {
            Sum -= sum;
            notify?.Invoke($&quot;Со счета снято: {sum}&quot;);   // 2.Вызов события
        }
        else
        {
            notify?.Invoke($&quot;Недостаточно денег на счете. Текущий баланс: {Sum}&quot;); ;
        }
    }
}
</code></pre>
<p>Теперь опредление события разбивается на две части. Вначале просто определяется переменная делегата, через которую мы можем вызывать связанные обработчики:</p>
<pre><code class="language-C#">AccountHandler notify;
</code></pre>
<p>Во второй части определяем акссесоры <code>add</code> и <code>remove</code>. Аксессор <code>add</code> вызывается при добавлении обработчика, то есть при операции +=. Добавляемый обработчик доступен через ключевое слово <code>value</code>. Здесь мы можем получить информацию об обработчике (например, имя метода через <code>value.Method.Name</code>) и определить некоторую логику. В данном случае для простоты просто выводится сообщение на консоль:</p>
<pre><code class="language-C#">add
{
    notify += value;
    Console.WriteLine($&quot;{value.Method.Name} добавлен&quot;);
}
</code></pre>
<p>Блок <code>remove</code> вызывается при удалении обработчика. Аналогично здесь можно задать некоторую дополнительную логику:</p>
<pre><code class="language-C#">remove
{
    notify -= value;
    Console.WriteLine($&quot;{value.Method.Name} удален&quot;);
}
</code></pre>
<p>Внутри класса событие вызывается также через переменную <code>notify</code>. Но для добавления и удаления обработчиков в программе используется как раз <code>Notify</code>:</p>
<pre><code class="language-C#">Account acc = new Account(100);
acc.Notify += DisplayMessage;       // добавляем обработчик DisplayMessage
acc.Put(20);    // добавляем на счет 20
acc.Notify -= DisplayMessage;     // удаляем обработчик DisplayMessage
acc.Put(20);    // добавляем на счет 20
 
void DisplayMessage(string message) =&gt; Console.WriteLine(message);
</code></pre>
<p>Консольный вывод программы:</p>
<pre><code class="language-console">DisplayMessage добавлен
На счет поступило: 20
DisplayMessage удален
</code></pre>
<h2 id="Передача-данных-события"><a class="header" href="#Передача-данных-события">Передача данных события</a></h2>
<p>Помимо простой строки, через событие можно передавать вообще любые данные.
Полученный урон в игре, нажатую клавишу, кнопку в интерфейсе и т.п.</p>
<h2 id="Утечки-памяти-при-работе-с-событиями"><a class="header" href="#Утечки-памяти-при-работе-с-событиями">Утечки памяти при работе с событиями</a></h2>
<p>При подписке на событие мы добавляем в список вызовов делегата события ссылку на метод, который будет вызван при вызове события. Таким образом, память, занимаемая объектом, подписавшимся на событие, не будет освобождена до его отписки от события или до уничтожения объекта, заключающего в себе событие. Эта особенность является одной из часто встречаемых причин утечек памяти в приложениях.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Модель-событий-net-framework"><a class="header" href="#Модель-событий-net-framework">Модель событий .NET Framework</a></h1>
<p>Все события в .NET Framework основаны на делегате <code>EventHandler</code>. Первый параметр этого делегата - это объект,
посылающий уведомление. 
В качестве второго параметра он принимает класс наследующий <code>EventArgs</code>. Использование такого
шаблона позволит подписываться на события, объявленные в классах .NET Framework. Класс <code>EventArgs</code> не содержит никакой полезной информации. Тем не менее он может быть использован в
ситуациях, когда важен сам факт того, что событие произошло. В этом случае нужно пользоваться полем Empty.
Также, от класса <code>EventArgs</code> можно наследовать, таким образом передавая полезную информацию о событии, например, так:</p>
<pre><code class="language-C#">public class SomeEventArgs : EventArgs
{
    public SomeEventArgs(string s) { message = s; }
    private string message;
    public string Message
    {
        get { return message; }
        set { message = value; }
    }
}
</code></pre>
<h2 id="Определения-eventhandler-и-eventargs-в-net-framework"><a class="header" href="#Определения-eventhandler-и-eventargs-в-net-framework">Определения <code>EventHandler</code> и <code>EventArgs</code> в .NET Framework.</a></h2>
<pre><code class="language-C#">public delegate void EventHandler( Object sender, EventArgs e );
</code></pre>
<pre><code class="language-C#">public class EventArgs
{
    public static readonly EventArgs Empty;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
