# События и их обработчики

## Определение и вызов событий

События — это особый вид многоадресного делегата, который может вызываться только из класса (или производных классов) или структуры, где они объявлены (класс издателя).

События объявляются в классе с помощью ключевого слова `event`, после которого указывается тип делегата, который представляет событие:

```C#
delegate void AccountHandler(string message);
event AccountHandler Notify;
```

В данном случае вначале определяется делегат `AccountHandler`, который принимает один параметр типа `string`. Затем с помощью ключевого слова `event` определяется событие с именем `Notify`, которое представляет делегат `AccountHandler`. Название для события может быть произвольным, но в любом случае оно должно представлять некоторый делегат.

Определив событие, мы можем его вызвать в программе как метод, используя имя события:

```C#
Notify("Произошло действие");
```

Поскольку событие `Notify` представляет делегат `AccountHandler`, который принимает один параметр типа `string` - строку, то при вызове события нам надо передать в него строку.

Однако при вызове событий мы можем столкнуться с тем, что событие равно `null` в случае, если для его не определен обработчик. Поэтому при вызове события лучше его всегда проверять на `null`. Например, так:

```C#
Notify?.Invoke("Произошло действие");
```

В этом случае поскольку событие представляет делегат, то мы можем его вызвать с помощью метода [Invoke()](./delegate.md#Метод-invoke), передав в него необходимые значения для параметров.

Создадим и вызовем событие:

```C#
class Account
{
    // В делегате определяем как будет выглядеть наше событие
    public delegate void AccountHandler(string message);

    // 1. Определение события
    public event AccountHandler? Notify;

    // Конструктор через лямбда выражение
    public Account(int sum) => Sum = sum;

    public int Sum { get; private set; }

    public void Put(int sum)
    {
        Sum += sum;
        Notify?.Invoke($"На счет поступило: {sum}");   // 2.Вызов события 
    }

    public void Take(int sum)
    {
        if (Sum >= sum)
        {
            Sum -= sum;
            Notify?.Invoke($"Со счета снято: {sum}");   // 2.Вызов события
        }
        else
        {
            Notify?.Invoke($"Недостаточно денег на счету. Текущий баланс: {Sum}"); ;
        }
    }
}
```

## Добавление обработчика события

С событием может быть связан один или несколько обработчиков. Обработчики событий - это именно то, что выполняется при вызове событий. Нередко в качестве обработчиков событий применяются методы. Каждый обработчик событий по списку параметров и возвращаемому типу должен соответствовать делегату, который представляет событие. Для добавления обработчика события применяется операция +=:

Определим обработчики для события `Notify`, чтобы получить в программе нужные уведомления:

```C#
void DisplayMessage(string message) => Console.WriteLine(message);
Account account = new Account(100);
account.Notify += DisplayMessage;   // Добавляем обработчик для события Notify

account.Put(20);    // добавляем на счет 20
// Наш обработчик перехватит событие, произошедшее в методе account.Put и выведет: На счет поступило: 20
```

При вызове события `Notify?.Invoke()` будет вызываться метод `DisplayMessage`, которому для параметра message будет передаваться строка, которая передается в `Notify?.Invoke()`. В `DisplayMessage` просто выводим полученное от события сообщение, но можно было бы определить любую логику.

Если бы в данном случае обработчик не был бы установлен, то при вызове события `Notify?.Invoke()` ничего не происходило, так как событие `Notify` было бы равно `null`.

## Добавление и удаление обработчиков

Для одного события можно установить несколько обработчиков и потом в любой момент времени их удалить.

```C#
void DisplayMessage(string message) => Console.WriteLine(message);
void DisplayBoldMessage(string message) => Console.WriteLine($"**{message}**");

Account account = new Account(100);
account.Notify += DisplayMessage;       // добавляем обработчик DisplayMessage
account.Notify += DisplayBoldMessage;    // добавляем обработчик DisplayRedMessage
account.Put(20);    // добавляем на счет 20
account.Notify -= DisplayBoldMessage;     // удаляем обработчик DisplayRedMessage
account.Put(50);    // добавляем на счет 50
```

```console
На счет поступило: 20
**На счет поступило: 20**
На счет поступило: 50
```

В качестве обработчиков могут использоваться не только обычные методы, но также делегаты, анонимные методы и лямбда-выражения:

```C#
void DisplayMessage(string message) => Console.WriteLine(message);

Account acc = new Account(100);
// установка делегата, который указывает на метод DisplayMessage
acc.Notify += new Account.AccountHandler(DisplayMessage);
// установка в качестве обработчика метода DisplayMessage
acc.Notify += DisplayMessage;       // добавляем обработчик DisplayMessage
 
acc.Put(20);    // добавляем на счет 20
```

В данном случае разницы между двумя обработчиками никакой не будет.

Установка в качестве обработчика анонимного метода:

```C#
Account acc = new Account(100);
acc.Notify += delegate (string mes)
{
    Console.WriteLine(mes);
};
acc.Put(20);
```

Установка в качестве обработчика лямбда-выражения:

```C#
Account account = new Account(100);
account.Notify += message => Console.WriteLine(message);
account.Put(20);
```

## Управление обработчиками

С помощью специальных акссесоров `add`/`remove` мы можем управлять добавлением и удалением обработчиков. Как правило, подобная функциональность редко требуется, но тем не менее мы ее можем использовать. Например:

```C#
class Account
{
    public delegate void AccountHandler(string message);
    AccountHandler? notify;
    public event AccountHandler Notify
    {
        add
        {
            notify += value;
            Console.WriteLine($"{value.Method.Name} добавлен");
        }
        remove
        {
            notify -= value;
            Console.WriteLine($"{value.Method.Name} удален");
        }
    }
    public Account(int sum) => Sum = sum;
    public int Sum { get; private set; }
    public void Put(int sum)
    {
        Sum += sum;
        notify?.Invoke($"На счет поступило: {sum}");   // 2.Вызов события 
    }
    public void Take(int sum)
    {
        if (Sum >= sum)
        {
            Sum -= sum;
            notify?.Invoke($"Со счета снято: {sum}");   // 2.Вызов события
        }
        else
        {
            notify?.Invoke($"Недостаточно денег на счете. Текущий баланс: {Sum}"); ;
        }
    }
}
```

Теперь опредление события разбивается на две части. Вначале просто определяется переменная делегата, через которую мы можем вызывать связанные обработчики:

```C#
AccountHandler notify;
```

Во второй части определяем акссесоры `add` и `remove`. Аксессор `add` вызывается при добавлении обработчика, то есть при операции +=. Добавляемый обработчик доступен через ключевое слово `value`. Здесь мы можем получить информацию об обработчике (например, имя метода через `value.Method.Name`) и определить некоторую логику. В данном случае для простоты просто выводится сообщение на консоль:

```C#
add
{
    notify += value;
    Console.WriteLine($"{value.Method.Name} добавлен");
}
```

Блок `remove` вызывается при удалении обработчика. Аналогично здесь можно задать некоторую дополнительную логику:

```C#
remove
{
    notify -= value;
    Console.WriteLine($"{value.Method.Name} удален");
}
```

Внутри класса событие вызывается также через переменную `notify`. Но для добавления и удаления обработчиков в программе используется как раз `Notify`:

```C#
Account acc = new Account(100);
acc.Notify += DisplayMessage;       // добавляем обработчик DisplayMessage
acc.Put(20);    // добавляем на счет 20
acc.Notify -= DisplayMessage;     // удаляем обработчик DisplayMessage
acc.Put(20);    // добавляем на счет 20
 
void DisplayMessage(string message) => Console.WriteLine(message);
```

Консольный вывод программы:

```console
DisplayMessage добавлен
На счет поступило: 20
DisplayMessage удален
```

## Передача данных события

Помимо простой строки, через событие можно передавать вообще любые данные.
Полученный урон в игре, нажатую клавишу, кнопку в интерфейсе и т.п.

## Утечки памяти при работе с событиями

При подписке на событие мы добавляем в список вызовов делегата события ссылку на метод, который будет вызван при вызове события. Таким образом, память, занимаемая объектом, подписавшимся на событие, не будет освобождена до его отписки от события или до уничтожения объекта, заключающего в себе событие. Эта особенность является одной из часто встречаемых причин утечек памяти в приложениях.