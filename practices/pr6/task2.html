<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Задание 2. Использование лямбда-выражений - ООП практические работы 5-8</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../intro.html"><strong aria-hidden="true">1.</strong> Введение</a></li><li class="chapter-item expanded "><a href="../../practices/pr5/p5.html"><strong aria-hidden="true">2.</strong> Практическая работа №5</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../practices/pr5/key_concepts.html"><strong aria-hidden="true">2.1.</strong> Ключевые понятия</a></li><li class="chapter-item expanded "><a href="../../practices/pr5/task1.html"><strong aria-hidden="true">2.2.</strong> Задание 1. Использование интерфейсов</a></li><li class="chapter-item expanded "><a href="../../practices/pr5/task2.html"><strong aria-hidden="true">2.3.</strong> Задание 2. Создание абстрактного класса</a></li><li class="chapter-item expanded "><a href="../../practices/pr5/task3.html"><strong aria-hidden="true">2.4.</strong> Задание 3. Создание архитектуры приложения с помощью интерфейсов</a></li></ol></li><li class="chapter-item expanded "><a href="../../practices/pr6/p6.html"><strong aria-hidden="true">3.</strong> Практическая работа №6</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../practices/pr6/key_concepts.html"><strong aria-hidden="true">3.1.</strong> Ключевые понятия</a></li><li class="chapter-item expanded "><a href="../../practices/pr6/task1.html"><strong aria-hidden="true">3.2.</strong> Задание 1. Использование событий</a></li><li class="chapter-item expanded "><a href="../../practices/pr6/task2.html" class="active"><strong aria-hidden="true">3.3.</strong> Задание 2. Использование лямбда-выражений</a></li><li class="chapter-item expanded "><a href="../../practices/pr6/task3.html"><strong aria-hidden="true">3.4.</strong> Задание 3. Создание собственных событий</a></li></ol></li><li class="chapter-item expanded "><a href="../../practices/pr7/p7.html"><strong aria-hidden="true">4.</strong> Практическая работа №7</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../practices/pr7/task1.html"><strong aria-hidden="true">4.1.</strong> Задание 1. Написать в отчет о практической работе небольшой авторский реферат о паттернах проектирования (В разработке)</a></li></ol></li><li class="chapter-item expanded "><a href="../../appendix/page.html"><strong aria-hidden="true">5.</strong> Приложение</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../appendix/vs_hotkeys.html"><strong aria-hidden="true">5.1.</strong> Visual studio хоткеи</a></li><li class="chapter-item expanded "><a href="../../appendix/interfaces.html"><strong aria-hidden="true">5.2.</strong> Интерфейсы</a></li><li class="chapter-item expanded "><a href="../../appendix/abstract_class.html"><strong aria-hidden="true">5.3.</strong> Абстрактный класс</a></li><li class="chapter-item expanded "><a href="../../appendix/multiple_interface_inherit.html"><strong aria-hidden="true">5.4.</strong> Множественное наследование</a></li><li class="chapter-item expanded "><a href="../../appendix/explicit_interfaces.html"><strong aria-hidden="true">5.5.</strong> Явная реализация интерфейсов</a></li><li class="chapter-item expanded "><a href="../../appendix/abstract_classes_vs_interfaces.html"><strong aria-hidden="true">5.6.</strong> Абстрактные классы vs интерфейсы</a></li><li class="chapter-item expanded "><a href="../../appendix/intefaces_and_abstract_classes_in_app_design.html"><strong aria-hidden="true">5.7.</strong> Справка по проектированию с использованием абстрактных классов и интерфейсов</a></li><li class="chapter-item expanded "><a href="../../appendix/delegate.html"><strong aria-hidden="true">5.8.</strong> Делегаты</a></li><li class="chapter-item expanded "><a href="../../appendix/lambda.html"><strong aria-hidden="true">5.9.</strong> Лямбда выражения</a></li><li class="chapter-item expanded "><a href="../../appendix/events.html"><strong aria-hidden="true">5.10.</strong> События и их обработчики</a></li><li class="chapter-item expanded "><a href="../../appendix/dot_net_events.html"><strong aria-hidden="true">5.11.</strong> Модель событий .NET Framework</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/main.html"><strong aria-hidden="true">5.12.</strong> Паттерны проектирования</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.1.</strong> Порождающие паттерны</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../appendix/patterns/abstract_factory.html"><strong aria-hidden="true">5.12.1.1.</strong> Абстрактная фабрика (Abstract Factory)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/builder.html"><strong aria-hidden="true">5.12.1.2.</strong> Строитель (Builder)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/factory_method.html"><strong aria-hidden="true">5.12.1.3.</strong> Фабричный метод (Factory Method)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/prototype.html"><strong aria-hidden="true">5.12.1.4.</strong> Прототип (Prototype)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/singleton.html"><strong aria-hidden="true">5.12.1.5.</strong> Одиночка (Singleton)</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.2.</strong> Структурные паттерны</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../appendix/patterns/adapter.html"><strong aria-hidden="true">5.12.2.1.</strong> Адаптер (Adapter)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/bridge.html"><strong aria-hidden="true">5.12.2.2.</strong> Мост (Bridge)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/composite.html"><strong aria-hidden="true">5.12.2.3.</strong> Компоновщик (Composite)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/decorator.html"><strong aria-hidden="true">5.12.2.4.</strong> Декоратор (Decorator)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/facade.html"><strong aria-hidden="true">5.12.2.5.</strong> Фасад (Facade)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/flyweight.html"><strong aria-hidden="true">5.12.2.6.</strong> Приспособленец (Flyweight)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/proxy.html"><strong aria-hidden="true">5.12.2.7.</strong> Заместитель (Proxy)</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.3.</strong> Поведенческие паттерны</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../appendix/patterns/chain.html"><strong aria-hidden="true">5.12.3.1.</strong> Цепочка обязанностей (Chain of responsibility)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/command.html"><strong aria-hidden="true">5.12.3.2.</strong> Команда (Command)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/interpreter.html"><strong aria-hidden="true">5.12.3.3.</strong> Интерпретатор (Interpreter)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/iterator.html"><strong aria-hidden="true">5.12.3.4.</strong> Итератор (Iterator)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/mediator.html"><strong aria-hidden="true">5.12.3.5.</strong> Посредник (Mediator)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/memento.html"><strong aria-hidden="true">5.12.3.6.</strong> Хранитель (Memento)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/observer.html"><strong aria-hidden="true">5.12.3.7.</strong> Наблюдатель (Observer)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/state.html"><strong aria-hidden="true">5.12.3.8.</strong> Состояние (State)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/strategy.html"><strong aria-hidden="true">5.12.3.9.</strong> Стратегия (Strategy)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/template_method.html"><strong aria-hidden="true">5.12.3.10.</strong> Шаблонный метод (Template method)</a></li><li class="chapter-item expanded "><a href="../../appendix/patterns/visitor.html"><strong aria-hidden="true">5.12.3.11.</strong> Посетитель (Visitor).</a></li></ol></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ООП практические работы 5-8</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Задание-2-Использование-лямбда-выражений"><a class="header" href="#Задание-2-Использование-лямбда-выражений">Задание 2. Использование лямбда-выражений</a></h1>
<p>В этом задании мы объявим новый тип делегата и новый тип <code>EventArgs</code> для поддержки события <code>HeartBeat</code>. Мы изменим интерфейс <code>IMeasuringDevice</code> и класс <code>MeasureDataDevice</code>, чтобы сгенерировать heartbeat с помощью объекта <code>BackgroundWorker</code>. Мы укажем код для запуска в новом потоке с помощью лямбда-выражения.</p>
<p>В обработчике событий <code>ReportProgress</code> мы реализуем код для уведомления клиентского приложения с помощью другого лямбда-выражения.</p>
<p>Мы будем обрабатывать событие <code>HeartBeat</code> в приложении с помощью лямбда-выражения.</p>
<blockquote>
<p><strong>Для выполнения данного задания необходимо скопировать своё решение из 1-го задания данной практики.</strong></p>
</blockquote>
<h2 id="Создаём-пользовательский-класс-аргументов-события"><a class="header" href="#Создаём-пользовательский-класс-аргументов-события">Создаём пользовательский класс аргументов события</a></h2>
<p>Нажимаем <strong>(Ctrl+Shift+A)</strong> и таким образом объявим класс <code>HeartBeatEventArgs</code>.
Небходимо добавить данный класс в пространство имён <code>MeasuringDevice</code>.
Также данный класс должен наследовать от класса <code>EventArgs</code>.</p>
<p>Должно получиться что-то похожее:</p>
<pre><code class="language-C#">namespace MeasuringDevice
{
    public class HeartBeatEventArgs: EventArgs
    {
    }
}
</code></pre>
<p>Пользовательский класс аргументов события может содержать любое количество свойств; эти свойства сохраняют информацию при возникновении события, позволяя обработчику событий получать информацию, относящуюся к событию, когда событие обрабатывается.</p>
<p>В класс <code>HeartBeatEventArgs</code> добавим доступное только для чтения авто-свойство <code>DateTime</code> с именем <code>TimeStamp</code>.</p>
<p>Добавим конструктор в класс <code>HeartBeatEventArgs</code>. Конструктор не должен принимать аргументы и инициализировать свойство <code>TimeStamp</code> датой и временем создания класса. Конструктор также должен расширять конструктор базового класса.</p>
<blockquote>
<p>Нажмите на класс, а затем нажмите <strong>(CTRL + '.')</strong>, после чего выберите &quot;Создать конструктор <code>HeartBeatEventArgs</code>&quot;</p>
</blockquote>
<p>Возможная реализация:</p>
<h3 id="heartbeateventargs"><a class="header" href="#heartbeateventargs">HeartBeatEventArgs</a></h3>
<pre><code class="language-C#">namespace MeasuringDevice
{
    public class HeartBeatEventArgs: EventArgs
    {
        public DateTime TimeStamp { get; }
        public HeartBeatEventArgs() : base()
        {
            TimeStamp = DateTime.Now;
        }
    }
}
</code></pre>
<h2 id="Объявление-обработчика-нашего-события"><a class="header" href="#Объявление-обработчика-нашего-события">Объявление обработчика нашего события</a></h2>
<p>В том же файле, либо в новом, объявим <code>public delegate</code> с названием <code>HeartBeatEventHandler</code>.</p>
<p>Делегат должен ссылаться на метод, который не возвращает значение, но имеет следующие параметры:</p>
<ul>
<li>Параметр типа <code>object</code> с именем <code>sender</code>.</li>
<li>Параметр <code>HeartBeatEventArgs</code> с именем <code>args</code>.</li>
</ul>
<p>Возможная реализация:</p>
<h3 id="heartbeateventhandler"><a class="header" href="#heartbeateventhandler">HeartBeatEventHandler</a></h3>
<pre><code class="language-C#">namespace MeasuringDevice
{
    public delegate void HeartBeatEventHandler (object sender, HeartBeatEventArgs e);
}
</code></pre>
<h2 id="Обновляем-интерфейс-ieventenabledmeasuringdevice"><a class="header" href="#Обновляем-интерфейс-ieventenabledmeasuringdevice">Обновляем интерфейс IEventEnabledMeasuringDevice.</a></h2>
<p>Откроем файл с интерфейсом <code>IEventEnabledMeasuringDevice</code>.</p>
<p>Добавим доступное только для чтения целочисленное авто-свойство с названием <code>HeartBeatInterval</code> в интерфейс.</p>
<p><strong>Если, конечно, такого свойства нет.</strong></p>
<p>Если что, примерно так должен выглядеть интефейс в итоге:</p>
<pre><code class="language-C#">namespace MeasuringDevice
{
    interface IEventEnabledMeasuringDevice : IMeasuringDevice
    {
        // Интервал Heartbeat, доступный только для чтения. Устанавливается только в конструкторе.
        int HeartBeatInterval { get; }

        event EventHandler NewMeasurementTaken;
        // Событие, которое должно срабатывать при каждом Heartbeat

        delegate void HeartBeatEventHandler();
        // Делегат для события HeartBeat

        event HeartBeatEventHandler HeartBeat;
    }
}
</code></pre>
<h2 id="Добавим-событие-heartbeat-и-свойство-heartbeatinterval-в-класс-measuredatadevice"><a class="header" href="#Добавим-событие-heartbeat-и-свойство-heartbeatinterval-в-класс-measuredatadevice">Добавим событие <code>HeartBeat</code> и свойство <code>HeartBeatInterval</code> в класс <code>MeasureDataDevice</code>.</a></h2>
<p>Найдём класс <code>MeasureDataDevice</code>. </p>
<p>Добавим <code>public int</code> свойство <code>HeartBeatInterval</code>, которое определяет интерфейс <code>IEventEnabledMeasuringDevice</code>. Свойство должно возвращать значение члена <code>heartBeatInterval</code> при вызове метода доступа <code>get</code>. Свойство должно иметь метод доступа <code>private set</code>, чтобы только конструктор мог установить свойство. Кстати, <code>heartBeatInterval</code> необходимо объявить самостоятельно. Лучше его сделать публичным...</p>
<p>Возможная реализация:</p>
<pre><code class="language-C#">public int heartBeatInterval;
public int HeartBeatInterval { get =&gt; heartBeatInterval; private set =&gt; heartBeatInterval = value; }
</code></pre>
<p>Добавим событие <code>HeartBeat</code>, которое определяет интерфейс <code>IEventEnabledMeasuringDevice</code>.</p>
<pre><code class="language-C#">public event HeartBeatEventHandler? HeartBeat;
</code></pre>
<p>Добавим <code>protected virtual void</code> метод <code>OnHeartBeat</code> не принимающий параметры.</p>
<p>В методе <code>OnHeartBeat</code> добавим код для выполнения следующих действий:</p>
<ul>
<li>Проверим что у события <code>HeartBeat</code> есть обработчики.</li>
<li>Если есть, вызовем событие, передавая текущий объект и новый экземпляр <code>HeartBeatEventArgs</code> как параметры.</li>
</ul>
<p>Возможная реализация:</p>
<pre><code class="language-C#">protected virtual void OnHeartBeat() =&gt; HeartBeat?.Invoke(this, new HeartBeatEventArgs());
</code></pre>
<h2 id="Используем-объект-backgroundworker-для-генерации-heartbeat"><a class="header" href="#Используем-объект-backgroundworker-для-генерации-heartbeat">Используем объект BackgroundWorker для генерации heartbeat</a></h2>
<p>определим <code>private</code> поле типа <code>BackgroundWorker</code> с именем <code>heartBeatTimer</code>.</p>
<p>Объявим закрытый метод с именем <code>StartHeartBeat</code>, который не принимает параметров и не возвращает значение.</p>
<p>Далее в этом методе:</p>
<ul>
<li>Создадим объект <code>heartBeatTimer</code> типа <code>BackgroundWorker</code></li>
<li>Настроим объект <code>heartBeatTimer</code> для поддержки отмены.</li>
<li>Настроим объект <code>heartBeatTimer</code> для поддержки уведомлений о ходе выполнения.</li>
</ul>
<p>Также в методе <code>StartHeartBeat</code> добавим обработчик для события <code>heartBeatTimer</code> <code>DoWork</code>, используя лямбда-выражение для определения выполняемых действий. Лямбда-выражение должно принимать два параметра (e, args). Внутри лямбда-выражения добавим цикл <code>while</code>, который постоянно повторяется и содержит код для выполнения следующих действий:</p>
<ul>
<li>запуск <code>Thread.Sleep</code>, чтобы перевести текущий поток в спящий режим на время, указанное в свойстве <code>HeartBeatInterval</code>.</li>
<li>Проверка значения свойства <code>disposed</code>. Если значение истинно, завершить цикл.</li>
<li>Вызов метода <code>heartBeatTimer.ReportProgress</code>, с параметром 0.</li>
</ul>
<blockquote>
<p>Примечание. Можно использовать составной оператор присваивания +=, чтобы указать, что метод будет обрабатывать событие <code>DoWork</code>, определить сигнатуру лямбда-выражения, а затем использовать оператор =&gt; для обозначения начала тела лямбда-выражения.</p>
</blockquote>
<p>В методе <code>StartHeartBeat</code> добавим обработчик события <code>heartBeatTimer.ReportProgress</code>, используя другое лямбда-выражение для создания тела метода. В тело лямбда-выражения добавим код для вызова метода <code>OnHeartBeat</code>, который вызывает событие <code>HeartBeat</code>.</p>
<p>В конце метода <code>StartHeartBeat</code> добавим строку кода, чтобы запустить асинхронно работающий объект <code>HeartBeatTimer</code> <code>BackgroundWorker</code>.</p>
<p>Возможная реализация:</p>
<pre><code class="language-C#">private void startHeartBeat()
{
    heartBeatTimer = new BackgroundWorker();
    heartBeatTimer.WorkerReportsProgress = true;
    heartBeatTimer.WorkerSupportsCancellation = true;
    heartBeatTimer.DoWork += (e, args) =&gt;
    {
        while (!disposed)
        {
            Thread.Sleep(heartBeatInterval);
            heartBeatTimer.ReportProgress(0);
        }
    };
    heartBeatTimer.ProgressChanged += (e, args) =&gt;
    {
        OnHeartBeat();
    };
    heartBeatTimer.RunWorkerAsync();
}
</code></pre>
<h2 id="Вызовем-метод-startheartbeat-при-запуске-объекта-measuredatadevice"><a class="header" href="#Вызовем-метод-startheartbeat-при-запуске-объекта-measuredatadevice">Вызовем метод StartHeartBeat при запуске объекта MeasureDataDevice.</a></h2>
<p>В методе StartCollecting добавим строчку чтобы вызвать метод <code>StartHeartBeat</code>
На этом моменте становится ясно, что небходимо будет удалить некоторый код из предедущего задания. Займёмся этим немного позже.</p>
<h2 id="Удалим-объект-heartbeattimer-backgroundworker-при-уничтожении-объекта-measuredatadevice"><a class="header" href="#Удалим-объект-heartbeattimer-backgroundworker-при-уничтожении-объекта-measuredatadevice">Удалим объект HeartBeatTimer BackgroundWorker при уничтожении объекта MeasureDataDevice.</a></h2>
<p>В методе <code>Dispose</code> добавим код для проверки того, что объект <code>HeartBeatTimer</code> <code>BackgroundWorker</code> не равен <code>null</code>. Если объект <code>heartBeatTimer</code> не равен <code>null</code>, вызовем метод <code>Dispose</code> объекта <code>BackgroundWorker</code>.</p>
<p>Теперь мы обновили абстрактный класс <code>MeasureDataDevice</code> для реализации обработчиков событий с помощью лямбда-выражений. Чтобы приложение могло воспользоваться этими изменениями, необходимо изменить класс <code>MeasureMassDevice</code>(А также чуть позже <code>MeasureLengthDevice</code>), который расширяет класс <code>MeasureDataDevice</code>.</p>
<h2 id="Обновим-конструктор-класса-measuremassdevice"><a class="header" href="#Обновим-конструктор-класса-measuremassdevice">Обновим конструктор класса MeasureMassDevice.</a></h2>
<ul>
<li>Откроем файл класса <code>MeasureMassDevice</code>.</li>
<li>Изменим сигнатуру конструктора, чтобы он принимал дополнительное целочисленное значение с именем <code>heartBeatInterval</code>.</li>
<li>Изменим тело конструктора, чтобы сохранить значение <code>heartBeatInterval</code> в  <code>heartBeatInterval</code> поле.</li>
</ul>
<p>Под существующим конструктором добавим второй конструктор, который принимает следующие параметры:</p>
<ul>
<li>Экземпляр <code>Units</code> с именем <code>deviceUnits</code>.</li>
<li>Строку <code>logFileName</code>.</li>
<li>Изменим новый конструктор, чтобы он неявно вызывал существующий конструктор. Передадим значение 1000 в качестве значения параметра <code>heartBeatInterval</code>.</li>
</ul>
<blockquote>
<p>Кстати, <code>logFileName</code> неизвестно вообще куда девать, поэтому можно тихонько от него избавиться, ну либо придумывать зачем он нам всё-таки нужен и как-то связывать с сохранением записей в файл.</p>
</blockquote>
<p>Возможная реализация:</p>
<pre><code class="language-C#">public MeasureMassDevice(Units unitsToUse, int heartBeatInterval)
{
    this.unitsToUse = unitsToUse;
    this.dataCaptured = new int[0];
    this.heartBeatInterval = heartBeatInterval;
}

public MeasureMassDevice(Units deviceUnits) : this(deviceUnits, 1000) { }
</code></pre>
<h2 id="Последние-штрихи-перед-работой-с-ui"><a class="header" href="#Последние-штрихи-перед-работой-с-ui">Последние штрихи перед работой с UI</a></h2>
<p>Теперь нужно разобраться с тем, что мы натворили.</p>
<p>С предедущего задания у нас остался <code>dataCollector</code>. Его стоит удалить из нашего абстрактного класса <code>MeasureDataDevice</code>.</p>
<p>Вместе с удалением <code>dataCollector</code> сломались методы <code>GetMeasurements</code> и <code>dataCollector_DoWork</code>. Смело их удаляем.</p>
<p>Некоторые методы также сломались, но там нужно просто подправить пару вещей и где-то заменить <code>dataCollector</code> на <code>heartBeatTimer</code>.</p>
<p>А теперь проделываем предедущий пункт с классом <code>MeasureLengthDevice</code>.</p>
<p>Далее можем запустить решение. Скорее всего всё соберётся и даже можно будет понажимать кнопочки, однако,
приложение ничего не будет делать.</p>
<p>А знаете почему оно ничего не делает? Потому что в  методе <code>startHeartBeat</code> класса <code>MeasureDataDevice</code> никто не позаботился о том, чтобы делать измерения. Таким образом необходимо прикрутить отвечающий за всё это код.</p>
<p>Возможная реализация:</p>
<h3 id="startheartbeat"><a class="header" href="#startheartbeat">startHeartBeat</a></h3>
<pre><code class="language-C#">private void startHeartBeat()
{
    dataCaptured = new int[10];
    int i = 0;
    heartBeatTimer = new BackgroundWorker();
    heartBeatTimer.WorkerReportsProgress = true;
    heartBeatTimer.WorkerSupportsCancellation = true;
    heartBeatTimer.DoWork += (e, args) =&gt;
    {
        while (heartBeatTimer?.CancellationPending == false &amp;&amp; disposed == false)
        {
            dataCaptured[i] = controller != null ? controller.TakeMeasurement() : dataCaptured[i];
            Thread.Sleep(heartBeatInterval);
            mostRecentMeasure = dataCaptured[i];
            loggingFileWriter?.WriteLine($&quot;Measurement - {mostRecentMeasure}&quot;);
            heartBeatTimer.ReportProgress(0);
            i = (i + 1) % 10;
        }
    };
    heartBeatTimer.ProgressChanged += (e, args) =&gt;
    {
        OnHeartBeat();
    };
    heartBeatTimer.RunWorkerAsync();
}
</code></pre>
<p>Ещё одна проблема - мы не удалили старый обработчик событий. Поэтому вот эту строчку также необходимо удалить:</p>
<pre><code class="language-C#">public event EventHandler? NewMeasurementTaken;
</code></pre>
<p>А вместе с ней и метод <code>OnNewMeasurementTaken</code>, а также <code>dataCollector_ProgressChanged</code>.</p>
<p>Также возможно придётся забраться в интерфейс <code>IEventEnabledMeasuringDevice</code> чтобы удалить оттуда строчку:</p>
<pre><code class="language-C#">event EventHandler NewMeasurementTaken;
</code></pre>
<h2 id="Работа-с-ui"><a class="header" href="#Работа-с-ui">Работа с UI</a></h2>
<p>Теперь в UI нам нужно подписаться на другой обработчик событий.</p>
<p>Где-то внутри формы среди скорее всего есть строчка:</p>
<pre><code class="language-C#">EventHandler newMeasurementTaken;
</code></pre>
<p>Её можно смело удалить.</p>
<p>Далее необходимо почистить метод, отвечающий за обработку нажатия &quot;Начать сбор данных&quot;.
Метод в итоге должен выглядить как-то так:</p>
<pre><code class="language-C#">private void startCollecting1_Click(object sender, EventArgs e)
{
    if (device1 == null)
    {
        MessageBox.Show(&quot;Устройство ещё не создано&quot;);
        return;
    }
    device1.StartCollecting();
}
</code></pre>
<p>Далее нам необходимо добавить обработчик события <code>device.HeartBeat</code>
В обработчике можно вызвать уже существующий в форме метод <code>device_NewMeasurementTaken</code>.
Этот метод отвечает за получение нового измерения.</p>
<p>Либо можно последовать методичке и реализовать вместо этого метода лямбда выражение, где мы могли бы добавить код для обновления метки <code>HeartBeat</code> <code>TimeStamp</code> текстом «HeartBeat Timestamp: timestamp», где timestamp — это значение свойства <code>args.TimeStamp</code>.</p>
<p>Дальнейшая реализация на ваше усмотрение.</p>
<p>Например, можно было бы реализовать так:</p>
<pre><code class="language-C#">private void startCollecting1_Click(object sender, EventArgs e)
{
    if (device1 == null)
    {
        MessageBox.Show(&quot;Устройство ещё не создано&quot;);
        return;
    }
    device1.HeartBeat += new HeartBeatEventHandler(device1_NewMeasurementTaken);
    device1.StartCollecting();
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../practices/pr6/task1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../practices/pr6/task3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../practices/pr6/task1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../practices/pr6/task3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
